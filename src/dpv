#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv instrument)"
#
#   4. Make sure pyenv is installed: brew install pyenv
#
# Usage:
#   Go to the directory of the project and call "dpv"
#   If it complains that the Python version is not installed, use: pyenv install <version>
#
set -e

function cmd_usage() {
	_load_config_vars

	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv             - installs virtualenv for the current directory"
	echo "  dpv usage       - display these instructions"
	echo "  dpv list        - lists virtualenvs managed by dpv"
	echo "  dpv where       - display the virtualenv directory"
	echo "  dpv version     - display version"
	echo "  dpv instrument  - instruments dpv"
	echo "  dpv run [cmd]   - runs command inside virtualenv [default: \$SHELL]"
	echo
	echo "  CTRL-D          - exits virtualenv"

}

function cmd_version() {
	_load_config_vars
	echo "$CFG_VERSION"
}

function cmd_where() {
	_load_config_vars
	_load_python_vars
	echo "$VENV_DIR"
}

function cmd_instrument() {
	trap - EXIT

	# https://stackoverflow.com/a/13864829
	if [ -n "${DPV_SHELL+x}" ]; then
		_load_config_vars
		_load_python_vars

		_print_venv_activate
	fi
}

function cmd_list() {
	case "$1" in
	--plain | *)
		_load_config_vars
		_plain_list
		;;
	esac
}

function cmd_run() {
	_load_config_vars
	_load_python_vars

	if [ ! -d "$VENV_DIR" ]; then
		_create_venv_if_not_exists
	fi

	_run_command "$@"
}

function cmd_install() {
	_load_config_vars
	_install
}

function err_detecting_python_version() {
	echo "cannot determine python version for $PWD" >/dev/stderr

	_print_exit_shell
}

function err_activate_virtualenv() {
	echo "cannot activate the virtualenv" >/dev/stderr

	_print_exit_shell
}

function __main() {
	trap '_error_handling $?' EXIT

	case "$1" in
	where)
		cmd_where
		;;

	instrument)
		cmd_instrument
		;;

	list | ls)
		cmd_list "${2:--plain}"
		;;

	run | "")
		cmd_run "${@:2}"
		# if [ "$#" -lt 2 ]; then
		# 	trap - EXIT
		# 	cmd_run "$SHELL"
		# else
		# 	cmd_run "${@:2}"
		# fi
		;;

	version | -v | --version)
		cmd_version
		;;

	install)
		cmd_install
		;;

	usage)
		cmd_usage
		;;

	*)
		trap - EXIT
		echo "?"
		exit 1
		;;

	esac
}

function _error_handling() {
	case "$1" in

	2)
		err_detecting_python_version
		;;

	3)
		err_activate_virtualenv
		;;

	esac

	if [ -z "${DPV_INSTRUMENT+x}" ]; then
		_print_logs
	fi
}

function _run_command() {
	if [ -n "${DPV_SHELL+x}" ]; then
		trap - EXIT
		exit 0
	fi

	if [ "$#" -eq 0 ]; then
		trap - EXIT
		DPV_SHELL=1 "$SHELL"
	else
		PATH=$VENV_DIR/bin:$PATH "$@"
	fi
}

function _load_config_vars() {
	CFG_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
	CFG_INSTALL_METHOD="${DPV_INSTALL_METHOD}"
	CFG_NO_LOGS="${DPV_NO_LOGS:-0}"

	# https://stackoverflow.com/a/677212
	if hash pyenv 2>/dev/null; then
		if [ "$CFG_INSTALL_METHOD" == "pyenv" ] || [ "$CFG_INSTALL_METHOD" == "" ]; then
			CFG_INSTALL_METHOD="pyenv"
			_log "- pyenv is installed (preferred)"
		else
			_log "- pyenv is installed but will not be used"
		fi
	fi
	if hash brew 2>/dev/null; then
		if [ "$CFG_INSTALL_METHOD" == "homebrew" ] || [ "$CFG_INSTALL_METHOD" == "" ]; then
			CFG_INSTALL_METHOD="homebrew"
			_log "- homebrew is installed (preferred)"
		else
			_log "- homebrew is installed but will not be used"
		fi
	fi

	CFG_VERSION="1.0.0"
	CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
	CFG_VENVS_DIR="$CFG_DIR/virtualenvs"

	mkdir -p "$CFG_VENVS_DIR"
}

function _load_python_vars() {
	PY_VERSION=$(_get_python_version)
	PY_PREFIX=$(_get_python_prefix)

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		PY_EXECUTABLE="$PY_PREFIX/bin/python"
		;;
	homebrew)
		PY_EXECUTABLE="$PY_PREFIX/bin/python3"
		;;
	esac

	VENV_DIR=$CFG_VENVS_DIR/$PY_VERSION/$(basename "$PWD")-$PY_VERSION
}

function _get_python_version() {
	local python_version
	if [ -f "runtime.txt" ]; then
		python_version=$(sed 's/^python\-//' <runtime.txt)
		_log "- parsed python version $python_version from runtime.txt file"
	else
		exit 2
	fi

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		_log "- checking installation of $python_version with pyenv"
		_log "$(sed s'/^/  > /' <(pyenv install "$python_version" --skip-existing 2>&1))"
		_log "  ok"
		;;
	homebrew)
		if [ "$(_util_count_char "$python_version" '.')" -gt 1 ]; then
			python_version=$(cut -d. -f1,2 <(echo "$python_version"))
			_log "- homebrew only supports 3.y python versions, using $python_version"
		fi
		_log "- checking installation of $python_version with homebrew"
		_log "$(sed 's/^/  > /' <(HOMEBREW_NO_AUTO_UPDATE=1 brew install "python@$python_version" 2>&1))"
		_log "  ok"
		;;
	esac

	echo "$python_version"
}

function _get_python_prefix() {
	case "$CFG_INSTALL_METHOD" in
	pyenv)
		pyenv prefix "$PY_VERSION"
		;;
	homebrew)
		brew --prefix "python@$PY_VERSION"
		;;
	esac
}

function _create_venv_if_not_exists() {
	if [ ! -d "$VENV_DIR" ]; then
		"$PY_EXECUTABLE" -m venv "$VENV_DIR"
	fi
}

function _print_venv_activate() {
	echo "source $VENV_DIR/bin/activate || exit 2"
}

function _plain_list() {
	find "$CFG_VENVS_DIR" -maxdepth 2 -mindepth 2
}

function _install() {
	while IFS= read -r line; do
		IFS=$'\t' read -r -a lst <<<"$line"
		PY_VERSION=${lst[0]}
		PY_PREFIX=$(_get_python_prefix)
		VENV_DIR="${lst[1]}"
		if [ ! -f "$PY_PREFIX" ]; then
			echo "Installing $VENV_DIR"
			_create_venv_if_not_exists
		fi
	done < <(_plain_list)
}

function _print_exit_shell() {
	if [ -n "${DPV_SHELL+x}" ]; then
		echo "unset DPV_SHELL"
		echo "exit 1"
	fi
}

function _log() {
	echo "$@" >>"$CFG_LOG_FILE"
}

function _print_logs() {
	if [ "$CFG_NO_LOGS" -eq 0 ]; then
		echo
		echo "logs:"
		sed 's/^/  /' <"$CFG_LOG_FILE"
		echo
	fi
}

function _util_count_char() {
	echo "$1" | tr -cd "$2" | wc -c
}

__main "$@"
