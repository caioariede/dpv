#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv internal-instrument)"
#
# Usage:
#   Go to the directory of the project and call "dpv"
#
# Code guidelines:
#
# 1. Internal commands should be prefixed with "internal-"
# 2. Commands are displayed in the usage by alphabetical order
# 3. There are four kinds of functions:
#    - command function
#    - command variant functions
#    - initialization functions
#    - short-hand functions
#    - utility functions
# 4. Command functions should be named "cmd_{command name}"
# 5. Command variants functions should be named "cmd_{command name}_{variant}"
# 6. Initialization functions should be named "init_{name}"
# 7. Short-hand functions differently than utilities are not pure
# 8. Utilities are "pure" functions and should be prefixed with "__"
# 9. Exit codes should be stored in constants prefixed with "ERR_"

set -eu
set -o pipefail

#
# Error exit codes
#

ERR_MAIN_INVALID_ARGUMENT=131
ERR_INSTALL_METHOD_NOT_SELECTED=132
ERR_CANNOT_ACTIVATE_VIRTUALENV=133
ERR_RUN_INVALID_ARGUMENT=134
ERR_CANNOT_DETERMINE_PYTHON_VERSION=135
ERR_NO_AVAILABLE_INSTALL_METHODS=136
ERR_CANNOT_RESOLVE_PYTHON_VERSION=137
ERR_VIRTUALENV_INSTALL_METHOD_NOT_AVAILABLE=138
ERR_INSTALLATION_FAILED=139
ERR_CANNOT_CREATE_VIRTUALENV=140
ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE=141

# VARS: Configuration
CFG_VERSION="0.9.2"
CFG_THEME="${DPV_THEME:-cat}"
CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
CFG_VIRTUALENVS_DIR="${DPV_MOCK_VIRTUALENVS_DIR:-$CFG_DIR/virtualenvs}"
CFG_PYENV_EXECUTABLE="${PYENV_EXECUTABLE:-pyenv}"
CFG_HOMEBREW_EXECUTABLE="${HOMEBREW_EXECUTABLE:-brew}"
CFG_PREFERRED_INSTALL_METHODS="pyenv homebrew"

# VARS: Internal
INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="${DPV_MOCK_PYENV_INSTALLED_PYTHON_VERSIONS:-ø}"
INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="${DPV_MOCK_PYENV_AVAILABLE_PYTHON_VERSIONS:-ø}"
INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS="${DPV_MOCK_HOMEBREW_INSTALLED_PYTHON_VERSIONS:-ø}"
INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS="${DPV_MOCK_HOMEBREW_AVAILABLE_PYTHON_VERSIONS:-ø}"
INTERNAL_AVAILABLE_INSTALL_METHODS="${DPV_MOCK_AVAILABLE_INSTALL_METHODS:-ø}"
INTERNAL_LOG_FILE="${DPV_MOCK_LOG_FILE:-ø}"
INTERNAL_SCAN_PYTHON_VERSION="${DPV_MOCK_SCAN_PYTHON_VERSION:-ø}"
INTERNAL_SCAN_PYTHON_VERSION_SOURCE="${DPV_MOCK_SCAN_PYTHON_VERSION_SOURCE:-ø}"
INTERNAL_RESOLVE_PYTHON_VERSION="${DPV_MOCK_RESOLVE_PYTHON_VERSION:-ø}"
INTERNAL_RESOLVE_INSTALL_METHOD="${DPV_MOCK_RESOLVE_INSTALL_METHOD:-ø}"
INTERNAL_ARG_PYTHON_VERSION="${DPV_MOCK_ARG_PYTHON_VERSION:-ø}"
INTERNAL_VIRTUALENV_INSTALL_METHOD="${DPV_MOCK_VIRTUALENV_INSTALL_METHOD:-ø}"
INTERNAL_VIRTUALENV_PYTHON_VERSION="${DPV_MOCK_VIRTUALENV_PYTHON_VERSION:-ø}"
INTERNAL_VIRTUALENV_DIR="${DPV_MOCK_VIRTUALENV_DIR:-ø}"

#
# Command functions
#
# These functions are called by the main() function
# Unsafe commands should set a trap to the error_handling() function
#

cmd_help() {
	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv [python version]"
	echo
	echo "commands:"
	echo "  dpv help             - display these instructions"
	echo "  dpv info             - display information about the current virtualenv"
	echo "  dpv list             - list virtualenvs created with dpv"
	echo "  dpv run [command]    - run command inside virtualenv [default: \$SHELL]"
	echo "    --python [version] - specify python version"
	echo "    --temp             - use a temporary virtualenv"
	echo "  dpv versions         - display available python versions"
	echo "    --all              - display extended list of available python versions"
	echo "  dpv drop             - remove current virtualenv"
	echo
	echo "global arguments:"
	echo "  --pyenv              - use pyenv"
	echo "  --homebrew           - use homebrew"
	echo
	echo "aliases:"
	echo "  dpv run / dpv"
	echo "  dpv [version] / dpv run --python [version]"
	echo "  dpv info / dpv (when virtualenv is activated)"
	echo "  dpv help / --help / -h"
	echo "  dpv list / --list / ls / -l"
	echo "  dpv versions / -v"
	echo "  dpv versions --all / -a"
	echo

	dpv_internal_print_config
}

cmd_versions() {
	trap 'error_handling $?' EXIT

	case "${1:-}" in
	--installed)
		echo "command: installed python versions"
		echo

		pyenv_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" | dpv_internal_filter_python_versions "pyenv" --all | dpv_format_nl_to_space)

		homebrew_load_installed_python_versions
		echo "homebrew:" $(echo "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" | dpv_internal_filter_python_versions "homebrew" --all | dpv_format_nl_to_space)

		;;

	--all | -a)
		echo "command: available python versions (extended list)"
		echo

		pyenv_load_available_python_versions
		pyenv_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_filter_python_versions "pyenv" --all | dpv_format_nl_to_space)

		homebrew_load_available_python_versions
		homebrew_load_installed_python_versions
		echo "homebrew:" $(echo "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_filter_python_versions "homebrew" --all | dpv_format_nl_to_space)
		;;

	"")
		echo "command: available python versions"
		echo

		pyenv_load_available_python_versions
		pyenv_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_filter_python_versions "pyenv" | dpv_format_nl_to_space)

		homebrew_load_available_python_versions
		homebrew_load_installed_python_versions
		echo "homebrew: $(echo "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_filter_python_versions "homebrew" | dpv_format_nl_to_space)"
		;;

	*)
		echo "error: unknown argument $1"
		;;

	esac
}

cmd_drop() {
	echo "command: drop virtualenv"
	echo

	if dpv_check_is_set "$DPV_VIRTUALENV_DIR"; then
		rm -rf "$DPV_VIRTUALENV_DIR"
		echo "dropped"
	else
		echo "error: virtualenv not activated"
		return
	fi
}

unsafe_cmd_internal_instrument() {
	#
	# Unsafe:
	# - unsafe_cmd_internal_instrument:
	#   - ERR_CANNOT_ACTIVATE_VIRTUALENV
	#
	dpv_check_is_set "$DPV_VIRTUALENV_DIR" || return

	echo "source $DPV_VIRTUALENV_DIR/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
}

cmd_list() {
	echo "command: list of virtualenvs"
	echo

	mkdir -p "$CFG_VIRTUALENVS_DIR"
	local sort_key="$(($(tr -cd '/' <<<"$CFG_VIRTUALENVS_DIR" | wc -c) + 3))"

	find "$CFG_VIRTUALENVS_DIR" -maxdepth 2 -mindepth 2 | sort --field-separator=/ --key "$sort_key" --ignore-case
}

cmd_info() {
	echo "command: info"
	echo

	if dpv_check_is_set "$DPV_VIRTUALENV_DIR"; then
		while IFS= read -r line; do
			declare "$(dpv_kv_parse_key "$line")"="$(dpv_kv_parse_val "$line")"
		done < <(dpv_internal_parse_virtualenv_config_file "$DPV_VIRTUALENV_DIR/dpv.cfg")

        printf "status: activated\n\n"
		printf "current virtualenv:\n"
		printf "  virtualenv path: $DPV_VIRTUALENV_DIR\n"
		printf "  project path: $path\n"
		printf "  python version: $version\n"
		printf "  installation method: $install_method\n"
		printf "\n"
    else
        printf "status: not activated\n\n"
	fi

	dpv_internal_print_config
}

unsafe_wrap_cmd_run() {
	#
	# Unsafe:
	# - unsafe_cmd_run:
	#   - ERR_RUN_INVALID_ARGUMENT
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	#
	if dpv_check_is_set "$DPV_VIRTUALENV_DIR"; then
		cmd_info | dpv_format_theme
	else
		unsafe_cmd_run $*
	fi
}

unsafe_cmd_run() {
	#
	# Unsafe:
	# - unsafe_cmd_run:
	#   - ERR_RUN_INVALID_ARGUMENT
	# - unsafe_dpv_internal_initialize_virtualenv:
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	# - unsafe_print_info
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	trap 'error_handling $?' EXIT

	CMD=""

	while [[ "$#" -gt 0 ]]; do
		if [ "$CMD" == "" ]; then
			case "$1" in
			--python)
				shift
				INTERNAL_ARG_PYTHON_VERSION="$1"
				shift
				;;
			--tmp | --temp)
				ARG_TEMP=1
				shift
				;;
			-*)
				echo "error: invalid argument: $1"
				exit "$ERR_RUN_INVALID_ARGUMENT"
				;;
			*)
				CMD=" $1"
				shift
				;;
			esac
		else
			CMD+=" $1"
			shift
		fi
	done

	CMD=${CMD:1}

	unsafe_dpv_internal_initialize_virtualenv

	trap - EXIT
	if [ "$CMD" == "" ]; then
		DPV_VIRTUALENV_DIR=$INTERNAL_VIRTUALENV_DIR unsafe_print_info
		DPV_VIRTUALENV_DIR=$INTERNAL_VIRTUALENV_DIR "$SHELL"
	else
		PATH=$INTERNAL_VIRTUALENV_DIR/bin:$PATH $CMD
	fi
}

#
# Internal functions
#

dpv_internal_print_config() {
	printf "config:\n"
	printf "  CFG_VIRTUALENVS_DIR=$CFG_VIRTUALENVS_DIR\n"
	printf "  CFG_THEME=$CFG_THEME\n"
	printf "  CFG_DIR=$CFG_DIR\n"
	printf "  CFG_PYENV_EXECUTABLE=$CFG_PYENV_EXECUTABLE\n"
	printf "  CFG_HOMEBREW_EXECUTABLE=$CFG_HOMEBREW_EXECUTABLE\n"
	printf "  CFG_PREFERRED_INSTALL_METHODS=$CFG_PREFERRED_INSTALL_METHODS\n"
}

unsafe_dpv_internal_initialize_virtualenv() {
	#
	# Tries to find an existing virtualenv matching the following:
	# 1. The directory path
	# 2. The Python version, if provided as an argument
	#
	# If not match, a Python version is asked to the user
	# Once a Python version is provided, look for the closest match:
	# 1. Already installed by one of the installation methods
	# 2. Available by one of the installation methods
	# 3. Error out (ERR_CANNOT_RESOLVE_PYTHON_VERSION)
	#
	# Loads:
	# - INTERNAL_VIRTUALENV_PYTHON_VERSION: The version resolved for the virtualenv
	# - INTERNAL_VIRTUALENV_INSTALL_METHOD: The installaton method resolved for the virtualenv
	# - INTERNAL_VIRTUALENV_DIR: The directory path for the virtualenv
	#
	# Unsafe:
	# - unsafe_dpv_internal_initialize_virtualenv:
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	# - unsafe_dpv_internal_set_available_install_methods:
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	if dpv_internal_scan_virtualenv; then
		# An existing virtualenv has been found, just use it
		return
	fi

	# Check available installation methods
	# If not possible, this will error out with: ERR_NO_AVAILABLE_INSTALL_METHODS
	unsafe_dpv_internal_set_available_install_methods

	# Try to determine the Python version to use
	# If not possible, this will error out with either:
	# - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	unsafe_dpv_internal_scan_python_version

	# Prompt user to confirm this is the Python version wanted
	local python_version_user_input
	read -rp "python version [default: $INTERNAL_SCAN_PYTHON_VERSION source: $INTERNAL_SCAN_PYTHON_VERSION_SOURCE]: " python_version_user_input
	INTERNAL_VIRTUALENV_PYTHON_VERSION="${python_version_user_input:-$INTERNAL_SCAN_PYTHON_VERSION}"

	# Resolve Python version
	# If not possible, this will error out with: ERR_CANNOT_RESOLVE_PYTHON_VERSION
	unsafe_dpv_internal_resolve_python_version "$INTERNAL_VIRTUALENV_PYTHON_VERSION"

	# Install Python version
	# If version is already installed, install will be skipped
	# If not possible, this will error out with: ERR_INSTALLATION_FAILED
	unsafe_${INTERNAL_VIRTUALENV_INSTALL_METHOD}_install <<<"$INTERNAL_VIRTUALENV_PYTHON_VERSION"

	# Create virtualenv
	# If not possible, this will error out with: ERR_CANNOT_CREATE_VIRTUALENV
	unsafe_dpv_internal_create_virtualenv
}

unsafe_dpv_internal_create_virtualenv() {
	#
	# Create a new virtualenv
	#
	# Unsafe:
	# - ERR_CANNOT_CREATE_VIRTUALENV
	# - ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE
	#
	if [ "${ARG_TEMP:-}" == "1" ]; then
		INTERNAL_VIRTUALENV_DIR=$(dpv_internal_mkdir_virtualenv_temporary)
	else
		INTERNAL_VIRTUALENV_DIR=$(dpv_internal_mkdir_virtualenv)
	fi

	echo "$INTERNAL_VIRTUALENV_INSTALL_METHOD: creating virtualenv..."
	local error=0
	(
		unsafe_${INTERNAL_VIRTUALENV_INSTALL_METHOD}_get_python_executable -m venv "$INTERNAL_VIRTUALENV_DIR" 2>&1 | sed 's/^/  > /'
	) || error=1
	if [ $error -eq 0 ]; then
		echo -e "path = $PWD\nversion = $INTERNAL_VIRTUALENV_PYTHON_VERSION\ninstall_method = $INTERNAL_VIRTUALENV_INSTALL_METHOD" >"$INTERNAL_VIRTUALENV_DIR/dpv.cfg"
		dpv_internal_log "created new virtualenv: $(basename "$INTERNAL_VIRTUALENV_DIR")"
		echo "$INTERNAL_VIRTUALENV_INSTALL_METHOD: done"
	else
		rm -rf "$INTERNAL_VIRTUALENV_DIR"
		echo "$INTERNAL_VIRTUALENV_INSTALL_METHOD: error"
		exit "$ERR_CANNOT_CREATE_VIRTUALENV"
	fi
}

unsafe_dpv_internal_resolve_python_version() {
	#
	# Tries to resolve a given Python version matching with:
	# 1. An already installed Python version
	# 2. An available Python version
	#
	# Unsafe:
	# - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	#
	local initial_version="$1"
	local from_installed=""
	local from_installed_version=""
	local from_available=""
	local from_available_version=""

	# Find matching Python versions among installed and available
	while IFS= read -r line; do
		for install in $line; do
			${install}_load_installed_python_versions
			${install}_load_available_python_versions

			local installed_versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS")
			local available_versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS")

			local installed_versions=${!installed_versions_var}
			local available_versions=${!available_versions_var}

			resolved_version=$(${install}_resolve_python_version <<<"$initial_version")
			if dpv_check_string_is_empty "$resolved_version"; then
				continue
			fi

			if [[ "$installed_versions" == *"$resolved_version"* ]]; then
				from_installed="$install"
				from_installed_version="$resolved_version"
				break 2
			elif [[ "$available_versions" == *"$resolved_version"* ]]; then
				from_available="$install"
				from_available_version="$resolved_version"
			fi
		done
	done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"

	if ! dpv_check_string_is_empty "$from_installed"; then
		# Give precedence to already installed Python versions, if any matches
		INTERNAL_RESOLVE_INSTALL_METHOD=$from_installed
		INTERNAL_RESOLVE_PYTHON_VERSION=$from_installed_version

		dpv_internal_log "$from_installed method selected"
		if [[ "$initial_version" != "$INTERNAL_RESOLVE_PYTHON_VERSION" ]]; then
			dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: resolved version $initial_version -> $INTERNAL_RESOLVE_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: version $from_installed_version already installed"

	elif ! dpv_check_string_is_empty "$from_available"; then
		# Otherwise offer an available Python version that needs to be installed, if any matches
		INTERNAL_RESOLVE_INSTALL_METHOD=$from_available
		INTERNAL_RESOLVE_PYTHON_VERSION=$from_available_version

		dpv_internal_log "$from_available method selected"
		if [[ "$initial_version" != "$INTERNAL_RESOLVE_PYTHON_VERSION" ]]; then
			dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: resolved version $initial_version -> $INTERNAL_RESOLVE_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: version $from_available_version needs to be installed"

	else
		# If there are not matches among installed and available Python versions, error out
		exit "$ERR_CANNOT_RESOLVE_PYTHON_VERSION"
	fi
}

dpv_internal_scan_virtualenv() {
	#
	# Tries to find an existing virtualenv for the project
	# The virtualenvs directory has the following tree layout:
	#
	# + root (stored in variable: CFG_VIRTUALENVS_DIR)
	#  \
	#   - venv-dir-1
	#   - venv-dir-2
	#   + venv-dir-3
	#    \
	#     + dpv.cfg
	#      \
	#       |------ file format ------|
	#       |-------------------------|
	#       | path = /path/to/project |
	#       | version = 3.9.2         | --> this is the Python version
	#       | install_method = pyenv  |
	#       |-------------------------|
	#
	mkdir -p "$CFG_VIRTUALENVS_DIR"

	# try to locate existing virtualenv
	while IFS= read -r file; do
		local path
		while IFS= read -r line; do
			declare "$(dpv_kv_parse_key "$line")"="$(dpv_kv_parse_val "$line")"
		done < <(dpv_internal_parse_virtualenv_config_file "$file")
		if [[ "$path" == "$PWD" ]]; then
			if ! dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION" || [[ "$version" == "$INTERNAL_ARG_PYTHON_VERSION"* ]]; then
				if ! dpv_check_is_set "$INTERNAL_VIRTUALENV_PYTHON_VERSION"; then
					dpv_internal_log "found virtualenv: $(basename "$(dirname "$file")") (selected first match)"
					INTERNAL_VIRTUALENV_PYTHON_VERSION=$version
					INTERNAL_VIRTUALENV_INSTALL_METHOD=$install_method
					if [ "${ARG_TEMP:-}" == "1" ]; then
						INTERNAL_VIRTUALENV_DIR=$(dpv_internal_mkdir_virtualenv_temporary)
					else
						INTERNAL_VIRTUALENV_DIR=$(dirname "$file")
					fi
				else
					dpv_internal_log "found virtualenv: $(basename "$(dirname "$file")") (skipped)"
				fi
			fi
		fi
	done < <(find "$CFG_VIRTUALENVS_DIR" -name dpv.cfg -type f -mindepth 3 -maxdepth 3)

	if ! dpv_check_is_set "$INTERNAL_VIRTUALENV_DIR"; then
		return 1
	fi
}

unsafe_dpv_internal_scan_python_version() {
	#
	# Tries to find the required Python version for a project in the following order:
	# 1. Check if a Python version was passed by argument
	# 2. Check if there is a runtime.txt file
	# 3. Check if there is a pyproject.toml file with a Python version
	# 4. Check if there is a Python version already installed with one of the install methods
	# 5. Check if there is a Python version available with one of the install methods
	#
	# Unsafe:
	# - unsafe_dpv_internal_scan_python_version:
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#
	if dpv_check_is_set "$INTERNAL_SCAN_PYTHON_VERSION_SOURCE"; then
		# already set
		return
	fi

	# use version provided by the user, if provided
	if dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION"; then
		INTERNAL_SCAN_PYTHON_VERSION_SOURCE="command-line"
		INTERNAL_SCAN_PYTHON_VERSION="$INTERNAL_ARG_PYTHON_VERSION"

		return
	fi

	# use version from runtime.txt, if available
	if [ -f "runtime.txt" ]; then
		INTERNAL_SCAN_PYTHON_VERSION_SOURCE="runtime.txt"
		INTERNAL_SCAN_PYTHON_VERSION=$(sed 's/^python\-//' <runtime.txt)

		return
	fi

	# use version from pyproject.toml, if available
	if [ -f "pyproject.toml" ]; then
		while IFS= read -r line; do
			if [[ "$line" =~ ^python\ *=\ *[\'\"][^0-9]*(.*)[\'\"] ]]; then
				INTERNAL_SCAN_PYTHON_VERSION_SOURCE="pyproject.toml"
				INTERNAL_SCAN_PYTHON_VERSION="${BASH_REMATCH[1]}"

				return
			fi
		done <"pyproject.toml"

		return
	fi

	# find installed version, if any
	while IFS= read -r line; do
		for install in $line; do
			${install}_load_installed_python_versions
			versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS")
			if ! dpv_check_string_is_empty "${!versions_var}"; then
				while read -r version; do
					INTERNAL_SCAN_PYTHON_VERSION=$version
					INTERNAL_SCAN_PYTHON_VERSION_SOURCE="already installed with $install"
					return
				done <<<"${!versions_var}"
			fi
		done
	done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"

	# find available version, if any
	if ! dpv_check_is_set "$INTERNAL_SCAN_PYTHON_VERSION"; then
		while IFS= read -r line; do
			for install in $line; do
				${install}_load_available_python_versions
				versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS")
				if ! dpv_check_string_is_empty "${!versions_var}"; then
					while read -r version; do
						INTERNAL_SCAN_PYTHON_VERSION=$version
						INTERNAL_SCAN_PYTHON_VERSION_SOURCE="can be installed with $install"
						return
					done <<<"${!versions_var}"
				fi
			done
		done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"
	fi

	exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
}

dpv_internal_parse_virtualenv_config_file() {
	local config_file="$1"

	local path=""
	local version=""
	local install_method=""

	while IFS= read -r line; do
		if [[ "$line" =~ ^path\ *=\ *(.*) ]]; then
			path="${BASH_REMATCH[1]}"
		elif [[ "$line" =~ ^version\ *=\ *(.*) ]]; then
			version="${BASH_REMATCH[1]}"
		elif [[ "$line" =~ ^install_method\ *=\ *(.*) ]]; then
			install_method="${BASH_REMATCH[1]}"
		fi
	done <"$config_file"

	local missing
	if dpv_check_string_is_empty "$path"; then missing+=", path"; fi
	if dpv_check_string_is_empty "$version"; then missing+=", version"; fi
	if dpv_check_string_is_empty "$install_method"; then missing+=", install_method"; fi

	if dpv_check_string_is_empty "$missing"; then
		echo "path = $path"
		echo "version = $version"
		echo "install_method = $install_method"
	else
		missing="$(dpv_string_lstrip 2 <<<"$missing")"
		dpv_internal_log "virtualenv config file missing: $missing (file: $config_file)"
		return 1
	fi
}

#
# Main function
#

main() {
	#
	# Unsafe:
	# - main:
	#   - ERR_MAIN_INVALID_ARGUMENT
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	# - unsafe_cmd_internal_instrument:
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	#   - ERR_CANNOT_ACTIVATE_VIRTUALENV
	# - unsafe_wrap_cmd_run:
	#   - ERR_RUN_INVALID_ARGUMENT
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	#

	# VARS: External/Overridable
	DPV_VIRTUALENV_DIR="${DPV_VIRTUALENV_DIR:-ø}"

	CMD=""
	CMD_ARGS=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		--pyenv)
			ARG_USE_PYENV=1
			;;
		--homebrew | --brew)
			ARG_USE_HOMEBREW=1
			;;
		--list)
			CMD="list"
			;;
		--info)
			CMD="info"
			;;
		--help)
			CMD="help"
			;;
		--*)
			CMD_ARGS+=" $i"
			;;
		*)
			if [ "$CMD" == "" ]; then
				CMD="$i"
			else
				CMD_ARGS+=" $i"
			fi
			;;
		esac
	done

	CMD_ARGS=${CMD_ARGS:1} # drop leading space

	# must happen after ARG_ variables are parsed
	if [ "${ARG_USE_PYENV:-} ${ARG_USE_HOMEBREW:-}" == "1 1" ]; then
		echo "you should specify either --pyenv or --homebrew, not both"
		exit $ERR_INSTALL_METHOD_NOT_SELECTED
	elif [ "${ARG_USE_PYENV:-}" == "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="pyenv"
	elif [ "${ARG_USE_HOMEBREW:-}" == "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="homebrew"
	fi

	dpv_internal_set_log_file

	case "$CMD" in
	internal-instrument)
		unsafe_cmd_internal_instrument
		;;

	list | --list | ls | -l)
		cmd_list | dpv_format_theme
		;;

	info)
		cmd_info | dpv_format_theme
		;;

	2* | 3* | 4*)
		if [[ "$CMD_ARGS" == *"--python"* ]]; then
			trap - EXIT
			echo "error: dpv cannot run \"dpv [version]\" with \"--python\" - use one or the other" | dpv_format_theme
			exit "$ERR_MAIN_INVALID_ARGUMENT"
		fi

		# shellcheck disable=2086
		unsafe_wrap_cmd_run --python "$CMD" $CMD_ARGS
		;;

	run | "")
		# shellcheck disable=2086
		unsafe_wrap_cmd_run $CMD_ARGS
		;;

	versions | -v)
		# shellcheck disable=2086
		cmd_versions $CMD_ARGS | dpv_format_theme
		;;

	drop | rm)
		cmd_drop
		;;

	help | --help | -h)
		cmd_help | dpv_format_theme
		;;

	*)
		echo "error: dpv invalid subcommand: $CMD" | dpv_format_theme
		exit "$ERR_MAIN_INVALID_ARGUMENT"
		;;

	esac
}

#
# Error-handling
#

error_handling() {
	case "$1" in

	"$ERR_MAIN_INVALID_ARGUMENT")
		echo "dpv - invalid argument"
		;;

	"$ERR_INSTALL_METHOD_NOT_SELECTED")
		echo "dpv - no installation method selected"
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		echo "dpv - failed to activate virtualenv $INTERNAL_VIRTUALENV_DIR"
		;;

	"$ERR_RUN_INVALID_ARGUMENT")
		echo "dpv - invalid argument passed to run"
		;;

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		echo "dpv - failed to determine python version for $PWD"
		;;

	"$ERR_NO_AVAILABLE_INSTALL_METHODS")
		echo "dpv - no installation methods available"
		;;

	"$ERR_CANNOT_RESOLVE_PYTHON_VERSION")
		echo "dpv - cannot resolve python version"
		;;

	"$ERR_VIRTUALENV_INSTALL_METHOD_NOT_AVAILABLE")
		echo "dpv - installation method defined by the virtualenv is not available"
		;;

	"$ERR_INSTALLATION_FAILED")
		echo "dpv - failed to install python version"
		;;

	esac

	dpv_internal_print_logs | dpv_format_theme
}

#
# Short-hand functions
#

unsafe_print_info() {
	#
	# Unsafe:
	# - unsafe_dpv_internal_set_available_install_methods
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	echo "dpv - $(basename "$DPV_VIRTUALENV_DIR") activated"

	# Check available installation methods
	# If not possible, this will error out with: ERR_NO_AVAILABLE_INSTALL_METHODS
	unsafe_dpv_internal_set_available_install_methods

	# Try to determine the Python version to use
	# If not possible, this will error out with either:
	# - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	unsafe_dpv_internal_scan_python_version

	dpv_internal_print_logs | dpv_format_theme
}

#
# Pyenv utils
#
pyenv_is_available() {
	hash "$CFG_PYENV_EXECUTABLE" 2>/dev/null
}

pyenv_exec() {
	"$CFG_PYENV_EXECUTABLE" "$@"
}

unsafe_pyenv_install() {
	while IFS= read -r python_version; do
		if [[ "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" == *"$python_version"* ]]; then
			continue
		fi
		echo "installing python $python_version using pyenv"
		local error=0
		(
			pyenv_exec install "$python_version" 2>&1 | sed 's/^/  > /'
		) || error=1
		if [ $error -eq 0 ]; then
			echo done
		else
			echo failed
			dpv_internal_log "pyenv: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

unsafe_pyenv_get_python_executable() {
	local cmd="$(pyenv_exec prefix "$INTERNAL_VIRTUALENV_PYTHON_VERSION")/bin/python"
	if [ -x "$cmd" ]; then
		echo "$cmd"
	else
		exit "$ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE"
	fi
}

pyenv_load_installed_python_versions() {
	dpv_check_is_set "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="$(while IFS= read -r line; do
		cut -d/ -f1 <<<"$line" | uniq
	done < <(dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE versions --bare --skip-aliases") | dpv_sort_versions)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS"; then
		return 1
	fi
}

pyenv_load_available_python_versions() {
	dpv_check_is_set "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="$(
		dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE install --list" | grep '^ ' | tr -d ' ' | dpv_sort_versions
		echo
	)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS"; then
		return 1
	fi
}

pyenv_resolve_python_version() {
	while read -r line; do
		local resolved_version=""
		local available_version="none"
		local major_version="$(cut -d. -f1,2 <<<"$line")"

		pyenv_load_installed_python_versions
		while IFS= read -r version; do
			if [[ "$version" == "$line"* ]]; then
				resolved_version=$version
				break
			elif [[ "$version" == "$major_version"* ]]; then
				available_version=$version
			fi
		done <<<"$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS"

		pyenv_load_available_python_versions
		if dpv_check_string_is_empty "$resolved_version"; then
			while IFS= read -r version; do
				if [[ "$version" == "$line"* ]]; then
					resolved_version=$version
					break
				elif [[ "$version" == "$major_version"* ]]; then
					available_version=$version
				fi
			done <<<"$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS"
		fi

		if ! dpv_check_string_is_empty "$resolved_version"; then
			echo $resolved_version
		elif [[ "$available_version" != "none" ]]; then
			echo $available_version
		fi
	done
}

#
# Homebrew utils
#
homebrew_is_available() {
	hash "$CFG_HOMEBREW_EXECUTABLE" 2>/dev/null
}

unsafe_homebrew_install() {
	while IFS= read -r python_version; do
		if [[ "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" == *"$python_version"* ]]; then
			continue
		fi
		echo "installing python $python_version using homebrew"
		local error=0
		(
			HOMEBREW_NO_AUTO_UPDATE=1 homebrew_exec install $(homebrew_format_python_formula <<<"$python_version") 2>&1 | sed 's/^/  > /'
		) || error=1
		if [ $error -eq 0 ]; then
			echo done
		else
			echo failed
			dpv_internal_log "homebrew: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

homebrew_exec() {
	"$CFG_HOMEBREW_EXECUTABLE" "$@"
}

unsafe_homebrew_get_python_executable() {
	local cmd="$(homebrew_exec --prefix $(homebrew_format_python_formula <<<"$INTERNAL_VIRTUALENV_PYTHON_VERSION") 2>/dev/null)"/libexec/bin/python
	if [ -x "$cmd" ]; then
		echo "$cmd"
	else
		exit "$ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE"
	fi
}

homebrew_load_installed_python_versions() {
	dpv_check_is_set "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" && return

	homebrew_load_available_python_versions

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE list" | grep 'python@' | cut -d@ -f2 | homebrew_expand_python_version | dpv_sort_versions); then
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=""
		return 1
	fi
}

homebrew_load_available_python_versions() {
	dpv_check_is_set "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" && return

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE search python"); then
		result=$(echo "$result" | grep -o 'python@[^ ]\+' | cut -d@ -f2 | homebrew_expand_python_version | dpv_sort_versions)
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=""
		return 1
	fi
}

homebrew_format_python_formula() {
	while read -r line; do
		echo "python@$(cut -d. -f1,2 <<<"$line")"
	done
}

homebrew_resolve_python_version() {
	homebrew_load_available_python_versions

	while read -r line; do
		local available_version="none"
		local major_version="$(cut -d. -f1,2 <<<"$line")"
		if [[ "$line" == "$major_version" ]]; then
			if [[ "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" == *"$major_version"* ]]; then
				homebrew_expand_python_version <<<"$major_version"
				continue
			fi
		else
			local version=$(homebrew_expand_python_version <<<"$major_version")
			if [[ "$version" == "$line" ]]; then
				echo $version
				continue
			fi
		fi
	done
}

homebrew_expand_python_version() {
	while read -r line; do
		major_version="$(cut -d. -f1,2 <<<"$line")"
		formula_path="$(homebrew_exec edit "$(homebrew_format_python_formula <<<"$major_version")" --print-path 2>/dev/null)" || return 1
		while IFS= read -r version; do
			echo $version
			break
		done < <(grep -o "$major_version\.[0-9]\+[a-z]*" "$formula_path")
	done
}

#
# Internals
#
dpv_internal_mkdir_virtualenv() {
	local dirname="$CFG_VIRTUALENVS_DIR/$INTERNAL_VIRTUALENV_PYTHON_VERSION/$(basename "$PWD")-$INTERNAL_VIRTUALENV_PYTHON_VERSION"
	mkdir -p "$dirname"
	printf $dirname
}

dpv_internal_mkdir_virtualenv_temporary() {
	local dirname="${TMPDIR:-/tmp/}$(basename "$PWD")-$INTERNAL_VIRTUALENV_PYTHON_VERSION.tmpXXXXX"
	mktemp -d "$dirname"
	printf $dirname
}

dpv_internal_set_log_file() {
	dpv_check_is_set "$INTERNAL_LOG_FILE" && return

	INTERNAL_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
}

unsafe_dpv_internal_set_available_install_methods() {
	#
	# Unsafe:
	# - unsafe_dpv_internal_set_available_install_methods:
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	dpv_check_is_set "$INTERNAL_AVAILABLE_INSTALL_METHODS" && return

	INTERNAL_AVAILABLE_INSTALL_METHODS="$(while IFS= read -r install; do
		if [[ ${install}_is_available ]]; then
			echo $install
		fi
	done <<<"$CFG_PREFERRED_INSTALL_METHODS")"

	if dpv_check_string_is_empty "$INTERNAL_AVAILABLE_INSTALL_METHODS"; then
		exit "$ERR_NO_AVAILABLE_INSTALL_METHODS"
	fi
}

dpv_internal_run_command_log_failure() {
	tmpfile=$(mktemp)

	# shellcheck disable=SC2068
	bash -c "$@" &>"$tmpfile"
	if [ "$?" -eq 0 ]; then
		cat "$tmpfile"
		return 0
	else
		dpv_internal_log "failed to run command: $*"
		echo -e "$(sed 's/^/  > /' <"$tmpfile")" >>"$INTERNAL_LOG_FILE"
		return 1
	fi
}

dpv_internal_print_logs() {
	if dpv_check_is_set "$INTERNAL_LOG_FILE" && ! dpv_check_file_is_empty "$INTERNAL_LOG_FILE"; then
		printf "\nlogs:\n"
		sed 's/^/  /' <"$INTERNAL_LOG_FILE"
	else
		printf "\nno logs\n"
	fi
}

dpv_internal_log() {
	echo -e "- $@" >>"$INTERNAL_LOG_FILE"
}

dpv_internal_filter_python_versions() {
	local install_method="$1"
	local options="${2:-}"

	local installed_versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install_method}_INSTALLED_PYTHON_VERSIONS")
	local installed_versions=${!installed_versions_var}

	if [[ " $options " == *" --all "* ]]; then
		while IFS= read -r line; do
			# check if installed
			for version in $installed_versions; do
				if [[ "$version" == "$line" ]]; then
					echo "$version*"
					continue 2
				fi
			done

			echo $line
		done

	else
		local skip

		while IFS= read -r line; do
			local major_version="$(dpv_format_major_version <<<"$line")"
			local fallback_installed=""

			# check if minor installed
			for version in $installed_versions; do
				if [[ "$version" == "$line" ]]; then
					if [[ " $skip " != *" $line "* ]]; then
						skip+=" $major_version "
						echo "$version*"
					fi
					continue 2
				elif [[ "$version" == "$major_version."* ]]; then
					fallback_installed="$version"
				fi
			done

			if [[ " $skip " == *" $major_version "* ]]; then
				continue
			else
				skip+=" $major_version "
			fi

			# fallback
			if [[ "$fallback_installed" != "" ]]; then
				skip+=" $fallback_installed "
				echo "$fallback_installed*"
				continue
			fi

			# check if mainstream
			if [[ ! "$line" =~ ^3.([789]|1[0-9]) ]] || [[ "$line" == *"rc"* ]] || [[ "$line" == *"dev"* ]]; then
				# Skip non-mainstream versions
				continue
			fi

			echo $line

		done
	fi
}

#
# General utils
#
dpv_sort_versions() {
	sort --version-sort --reverse
}

dpv_format_nl_to_space() {
	echo -n "$(cat)" | tr '\n' ' '
}

dpv_format_major_version() {
	cut -d. -f1,2
}

dpv_format_theme() {
	"$CFG_THEME"
}

dpv_filter_unique_major_versions() {
	local last_major_version
	while IFS= read -r version; do
		local major_version="$(dpv_format_major_version <<<"$version")"
		if [[ "$major_version" != "$last_major_version" ]]; then
			echo $version
			last_major_version=$major_version
		fi
	done
}

dpv_check_file_is_empty() {
	# -s :: Size is > 0 bytes
	! [ -s "$1" ]
}

dpv_check_string_is_empty() {
	# -z :: String is empty
	[[ -z "$1" ]]
}

dpv_check_is_set() {
	# "ø" :: Special value for empty/unset
	[[ "$1" != "ø" ]]
}

dpv_string_lstrip() {
	local remove_after_including="$(($1 + 1))"
	cut -c "$remove_after_including"-
}

dpv_kv_parse_key() {
	# https://stackoverflow.com/a/20348190
	echo ${@%% = *}
}

dpv_kv_parse_val() {
	# https://stackoverflow.com/a/15149278
	echo ${@#* = }
}

# https://stackoverflow.com/a/28776166
(return 0 2>/dev/null) || main "$@"
