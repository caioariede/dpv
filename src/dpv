#!/usr/bin/env bash
#
# the d̲ead simple P̲ython v̲irtualenv manager for the stoic programmer
#
#
# LICENCE
# =====================================================================================
#
# MIT License
#
# Copyright (c) 2023 Caio Ariede
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
# INSTALLATION
# =====================================================================================
#
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv internal-load-shell)"
#
#
# USAGE
# =====================================================================================
#
#   Type: dpv help
#
#
# CODE GUIDELINES
# =====================================================================================
#
# 1. Functions must be prefixed with "dpv_"
# 2. Unsafe functions (one that may exit) must be prefixed with "unsafe_dpv_"
# 3. Stateful functions (depending on CFG_ or INTERNAL_ vars) must be prefixed with "dpv_internal_"
# 4. Functions that perform operations over pipes must be prefixed with "dpv_pipe_"
# 5. Functions that returns boolean must be prefixed with "dpv_check_"
# 6. The ø character is used to define emptiness (empty value)
# 7. Exit codes are stored in variables prefixed with "ERR_"
# 8. Configuration values are stored in variables prefixed with "CFG_"
# 9. Vendor functions are prefixed with "dpv_VENDOR_" (vendor must be in uppercase)
#

set -eu
set -o pipefail

#
# Error exit codes
#

ERR_MAIN_INVALID_ARGUMENT=131
ERR_INSTALL_METHOD_NOT_SELECTED=132
ERR_CANNOT_ACTIVATE_VIRTUALENV=133
ERR_RUN_INVALID_ARGUMENT=134
ERR_CANNOT_DETERMINE_PYTHON_VERSION=135
ERR_NO_AVAILABLE_INSTALL_METHODS=136
ERR_CANNOT_RESOLVE_PYTHON_VERSION=137
ERR_VIRTUALENV_INSTALL_METHOD_NOT_AVAILABLE=138
ERR_INSTALLATION_FAILED=139
ERR_CANNOT_CREATE_VIRTUALENV=140
ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE=141

# VARS: Configuration
CFG_VERSION="0.9.4"
CFG_THEME="${DPV_THEME:-cat}"
CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
CFG_VIRTUALENVS_DIR="${DPV_MOCK_VIRTUALENVS_DIR:-$CFG_DIR/virtualenvs}"
CFG_PYENV_EXECUTABLE="${PYENV_EXECUTABLE:-pyenv}"
CFG_HOMEBREW_EXECUTABLE="${HOMEBREW_EXECUTABLE:-brew}"
CFG_PREFERRED_INSTALL_METHODS="PYENV HOMEBREW"

# VARS: Internal
INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="${DPV_MOCK_PYENV_INSTALLED_PYTHON_VERSIONS:-ø}"
INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="${DPV_MOCK_PYENV_AVAILABLE_PYTHON_VERSIONS:-ø}"
INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS="${DPV_MOCK_HOMEBREW_INSTALLED_PYTHON_VERSIONS:-ø}"
INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS="${DPV_MOCK_HOMEBREW_AVAILABLE_PYTHON_VERSIONS:-ø}"
INTERNAL_AVAILABLE_INSTALL_METHODS="${DPV_MOCK_AVAILABLE_INSTALL_METHODS:-ø}"
INTERNAL_LOG_FILE="${DPV_MOCK_LOG_FILE:-ø}"
INTERNAL_RESOLVE_PYTHON_VERSION="${DPV_MOCK_RESOLVE_PYTHON_VERSION:-ø}"
INTERNAL_RESOLVE_INSTALL_METHOD="${DPV_MOCK_RESOLVE_INSTALL_METHOD:-ø}"
INTERNAL_ARG_PYTHON_VERSION="${DPV_MOCK_ARG_PYTHON_VERSION:-ø}"
INTERNAL_VIRTUALENV_INSTALL_METHOD="${DPV_MOCK_VIRTUALENV_INSTALL_METHOD:-ø}"
INTERNAL_VIRTUALENV_PYTHON_VERSION="${DPV_MOCK_VIRTUALENV_PYTHON_VERSION:-ø}"
INTERNAL_VIRTUALENV_DIR="${DPV_MOCK_VIRTUALENV_DIR:-ø}"

#
# Command functions
#
# These functions are called by the dpv_main() function
# Unsafe commands should set a trap to the dpv_error_handling() function
#

dpv_cmd_help() {
	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv [python version]"
	echo
	echo "commands:"
	echo "  dpv help             - display these instructions"
	echo "  dpv info             - display information about the current virtualenv"
	echo "  dpv list             - list virtualenvs created with dpv"
	echo "  dpv run [command]    - run command inside virtualenv [default: \$SHELL]"
	echo "    --python [version] - specify python version"
	echo "    --temp             - use a temporary virtualenv"
	echo "  dpv versions         - display available python versions"
	echo "    --all              - display extended list of available python versions"
	echo "  dpv drop             - remove current virtualenv"
	echo
	echo "global arguments:"
	echo "  --pyenv              - use pyenv"
	echo "  --homebrew           - use homebrew"
	echo
	echo "aliases:"
	echo "  dpv run / dpv"
	echo "  dpv [version] / dpv run --python [version]"
	echo "  dpv info / dpv (when virtualenv is activated)"
	echo "  dpv help / --help / -h"
	echo "  dpv list / --list / ls / -l"
	echo "  dpv versions / -v"
	echo "  dpv versions --all / -a"
	echo

	dpv_internal_print_config
}

dpv_cmd_versions() {
	trap 'dpv_error_handling $?' EXIT

	case "${1:-}" in
	--installed)
		echo "command: installed python versions"
		echo

		dpv_PYENV_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" | dpv_internal_pipe_format_python_versions "PYENV" --all | dpv_pipe_format_nl_to_space)

		dpv_HOMEBREW_load_installed_python_versions
		echo "homebrew:" $(echo "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" | dpv_internal_pipe_format_python_versions "HOMEBREW" --all | dpv_pipe_format_nl_to_space)

		;;

	--all | -a)
		echo "command: available python versions (extended list)"
		echo

		dpv_PYENV_load_available_python_versions
		dpv_PYENV_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_pipe_format_python_versions "PYENV" --all | dpv_pipe_format_nl_to_space)

		dpv_HOMEBREW_load_available_python_versions
		dpv_HOMEBREW_load_installed_python_versions
		echo "homebrew:" $(echo "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_pipe_format_python_versions "HOMEBREW" --all | dpv_pipe_format_nl_to_space)
		;;

	"")
		echo "command: available python versions"
		echo

		dpv_PYENV_load_available_python_versions
		dpv_PYENV_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_pipe_format_python_versions "PYENV" | dpv_pipe_format_nl_to_space)

		dpv_HOMEBREW_load_available_python_versions
		dpv_HOMEBREW_load_installed_python_versions
		echo "homebrew: $(echo "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" | dpv_internal_pipe_format_python_versions "HOMEBREW" | dpv_pipe_format_nl_to_space)"
		;;

	*)
		echo "error: unknown argument $1"
		;;

	esac
}

dpv_cmd_drop() {
	echo "command: drop virtualenv"
	echo

	if dpv_check_is_set "$DPV_VIRTUALENV_DIR"; then
		rm -rf "$DPV_VIRTUALENV_DIR"
		echo "dropped"
	else
		echo "error: virtualenv not activated"
		return
	fi
}

unsafe_dpv_cmd_internal_load_shell() {
	dpv_check_is_set "$DPV_VIRTUALENV_DIR" || return

	echo "source $DPV_VIRTUALENV_DIR/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
}

dpv_cmd_list() {
	echo "command: list of virtualenvs"
	echo

	mkdir -p "$CFG_VIRTUALENVS_DIR"
	local sort_key="$(($(dpv_string_count_characters "$CFG_VIRTUALENVS_DIR" "/") + 3))"

	find "$CFG_VIRTUALENVS_DIR" -maxdepth 2 -mindepth 2 | sort --field-separator=/ --key "$sort_key" --ignore-case
}

dpv_cmd_info() {
	echo "command: info"
	echo

	# Check available installation methods
	# If not possible, this will error out with: ERR_NO_AVAILABLE_INSTALL_METHODS
	unsafe_dpv_internal_set_available_install_methods

	dpv_internal_scan_virtualenv 1>/dev/null || true
	dpv_internal_scan_python_version 1>/dev/null || true

	dpv_internal_print_status

	if dpv_check_is_set "$DPV_VIRTUALENV_DIR"; then
		dpv_internal_print_current_virtualenv
		printf "\n"
	fi

	dpv_internal_print_config
	dpv_internal_print_logs
}

unsafe_dpv_cmd_run_wrapper() {
	if dpv_check_is_set "$DPV_VIRTUALENV_DIR"; then
		dpv_cmd_info | dpv_pipe_format_theme
	else
		unsafe_dpv_cmd_run $*
	fi
}

unsafe_dpv_cmd_run() {
	trap 'dpv_error_handling $?' EXIT

	CMD=""

	while [[ "$#" -gt 0 ]]; do
		if [ "$CMD" == "" ]; then
			case "$1" in
			--python)
				shift
				INTERNAL_ARG_PYTHON_VERSION="$1"
				shift
				;;
			--tmp | --temp)
				ARG_TEMP=1
				shift
				;;
			-*)
				echo "error: invalid argument: $1"
				exit "$ERR_RUN_INVALID_ARGUMENT"
				;;
			*)
				CMD=" $1"
				shift
				;;
			esac
		else
			CMD+=" $1"
			shift
		fi
	done

	CMD=${CMD:1}

	unsafe_dpv_internal_initialize_virtualenv

	trap - EXIT
	if [ "$CMD" == "" ]; then
		DPV_VIRTUALENV_DIR=$INTERNAL_VIRTUALENV_DIR dpv_internal_print_shell_banner | dpv_pipe_format_theme
		DPV_VIRTUALENV_DIR=$INTERNAL_VIRTUALENV_DIR "$SHELL"
	else
		PATH=$INTERNAL_VIRTUALENV_DIR/bin:$PATH $CMD
	fi
}

#
# Internal functions
#
dpv_internal_print_shell_banner() {
	printf "command: shell\n\n"

	dpv_internal_print_status
	dpv_internal_print_current_virtualenv
	dpv_internal_print_logs
}

dpv_internal_print_status() {
	if dpv_check_is_set "$DPV_VIRTUALENV_DIR"; then
		printf "status: activated\n\n"
	else
		printf "status: not activated\n\n"
	fi
}

dpv_internal_print_config() {
	printf "config:\n"
	printf "  CFG_VIRTUALENVS_DIR=$CFG_VIRTUALENVS_DIR\n"
	printf "  CFG_THEME=$CFG_THEME\n"
	printf "  CFG_DIR=$CFG_DIR\n"
	printf "  CFG_PYENV_EXECUTABLE=$CFG_PYENV_EXECUTABLE\n"
	printf "  CFG_HOMEBREW_EXECUTABLE=$CFG_HOMEBREW_EXECUTABLE\n"
	printf "  CFG_PREFERRED_INSTALL_METHODS=$CFG_PREFERRED_INSTALL_METHODS\n"
}

dpv_internal_print_current_virtualenv() {
	IFS=$'\n' read -d '' -r path version install_method <<<"$(dpv_internal_parse_virtualenv_config_file "$DPV_VIRTUALENV_DIR/dpv.cfg" | dpv_kv_get "path" "version" "install_method")" || true

	printf "current virtualenv:\n"
	printf "  virtualenv path: $DPV_VIRTUALENV_DIR\n"
	printf "  project path: $path\n"
	printf "  python version: $version\n"
	printf "  installation method: $install_method\n"
}

dpv_internal_print_logs() {
	if dpv_check_is_set "$INTERNAL_LOG_FILE" && ! dpv_check_file_is_empty "$INTERNAL_LOG_FILE"; then
		printf "\nlogs:\n"
		dpv_pipe_quote "-" <"$INTERNAL_LOG_FILE"
	fi
}

unsafe_dpv_internal_initialize_virtualenv() {
	#
	# Tries to find an existing virtualenv matching the following:
	# 1. The directory path
	# 2. The Python version, if provided as an argument
	#
	# If not match, a Python version is asked to the user
	# Once a Python version is provided, look for the closest match:
	# 1. Already installed by one of the installation methods
	# 2. Available by one of the installation methods
	# 3. Error out (ERR_CANNOT_RESOLVE_PYTHON_VERSION)
	#
	# Loads:
	# - INTERNAL_VIRTUALENV_PYTHON_VERSION: The version resolved for the virtualenv
	# - INTERNAL_VIRTUALENV_INSTALL_METHOD: The installaton method resolved for the virtualenv
	# - INTERNAL_VIRTUALENV_DIR: The directory path for the virtualenv
	#
	# Unsafe:
	# - unsafe_dpv_internal_initialize_virtualenv:
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	# - unsafe_dpv_internal_set_available_install_methods:
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	local virtualenv_dir="ø"
	while IFS= read -r line; do
		declare "$(dpv_kv_parse_key "$line")"="$(dpv_kv_parse_val "$line")"
	done < <(dpv_internal_scan_virtualenv)

	if dpv_check_is_set "$virtualenv_dir"; then
		# An existing virtualenv has been found, just use it
		INTERNAL_VIRTUALENV_PYTHON_VERSION=$version
		INTERNAL_VIRTUALENV_INSTALL_METHOD=$install_method
		INTERNAL_VIRTUALENV_DIR=$virtualenv_dir
		return
	fi

	# Check available installation methods
	# If not possible, this will error out with: ERR_NO_AVAILABLE_INSTALL_METHODS
	unsafe_dpv_internal_set_available_install_methods

	# Try to determine the Python version to use
	# If not possible, this will error out
	IFS=$'\n' read -d '' -r scan_python_source scan_python_version <<<"$(dpv_internal_scan_python_version | dpv_kv_get "source" "version")" || true
	if ! dpv_check_is_set "$scan_python_source"; then
		exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
	fi

	# Prompt user to confirm this is the Python version wanted
	local python_version_user_input
	read -rp "python version [default: $scan_python_version source: $scan_python_source]: " python_version_user_input
	INTERNAL_VIRTUALENV_PYTHON_VERSION="${python_version_user_input:-$scan_python_version}"

	# Resolve Python version
	# If not possible, this will error out with: ERR_CANNOT_RESOLVE_PYTHON_VERSION
	IFS=$'\n' read -d '' -r resolve_python_version resolve_install_method <<<"$(dpv_internal_resolve_python_version "$INTERNAL_VIRTUALENV_PYTHON_VERSION" | dpv_kv_get "version" "install_method")" || true
	if ! dpv_check_is_set "$resolve_python_version"; then
		exit "$ERR_CANNOT_RESOLVE_PYTHON_VERSION"
	fi

	# Install Python version
	# If version is already installed, install will be skipped
	# If not possible, this will error out with: ERR_INSTALLATION_FAILED
	unsafe_dpv_${INTERNAL_VIRTUALENV_INSTALL_METHOD}_install <<<"$INTERNAL_VIRTUALENV_PYTHON_VERSION"

	# Create virtualenv
	# If not possible, this will error out with: ERR_CANNOT_CREATE_VIRTUALENV
	unsafe_dpv_internal_create_virtualenv
}

unsafe_dpv_internal_create_virtualenv() {
	#
	# Create a new virtualenv
	#
	# Unsafe:
	# - ERR_CANNOT_CREATE_VIRTUALENV
	# - ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE
	#
	if [ "${ARG_TEMP:-}" == "1" ]; then
		INTERNAL_VIRTUALENV_DIR=$(dpv_internal_mkdir_virtualenv_temporary)
	else
		INTERNAL_VIRTUALENV_DIR=$(dpv_internal_mkdir_virtualenv)
	fi

	local vendor_prefix="$(dpv_string_lowercase "$INTERNAL_VIRTUALENV_INSTALL_METHOD"):"

	echo "$vendor_prefix creating virtualenv..."
	local error=0
	(
		unsafe_dpv_${INTERNAL_VIRTUALENV_INSTALL_METHOD}_get_python_executable -m venv "$INTERNAL_VIRTUALENV_DIR" 2>&1 | dpv_pipe_quote
	) || error=1
	if [ $error -eq 0 ]; then
		echo -e "path = $PWD\nversion = $INTERNAL_VIRTUALENV_PYTHON_VERSION\ninstall_method = $INTERNAL_VIRTUALENV_INSTALL_METHOD" >"$INTERNAL_VIRTUALENV_DIR/dpv.cfg"
		dpv_internal_log "created new virtualenv: $(basename "$INTERNAL_VIRTUALENV_DIR")"
		echo "$vendor_prefix done"
	else
		rm -rf "$INTERNAL_VIRTUALENV_DIR"
		echo "$vendor_prefix error"
		exit "$ERR_CANNOT_CREATE_VIRTUALENV"
	fi
}

dpv_internal_resolve_python_version() {
	#
	# Tries to resolve a given Python version matching with:
	# 1. An already installed Python version
	# 2. An available Python version
	#
	local initial_version="$1"
	local from_installed=""
	local from_installed_version=""
	local from_available=""
	local from_available_version=""

	# Find matching Python versions among installed and available
	while IFS= read -r line; do
		for install in $line; do
			dpv_${install}_load_installed_python_versions
			dpv_${install}_load_available_python_versions

			local installed_versions_var="INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS"
			local available_versions_var="INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS"

			local installed_versions=${!installed_versions_var}
			local available_versions=${!available_versions_var}

			resolved_version=$(dpv_${install}_resolve_python_version <<<"$initial_version")
			if dpv_check_string_is_empty "$resolved_version"; then
				continue
			fi

			if [[ "$installed_versions" == *"$resolved_version"* ]]; then
				from_installed="$install"
				from_installed_version="$resolved_version"
				break 2
			elif [[ "$available_versions" == *"$resolved_version"* ]]; then
				from_available="$install"
				from_available_version="$resolved_version"
			fi
		done
	done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"

	if ! dpv_check_string_is_empty "$from_installed"; then
		# Give precedence to already installed Python versions, if any matches
		dpv_kv_print "install_method" "$from_installed"
		dpv_kv_print "version" "$from_installed_version"

		dpv_internal_log "$from_installed method selected"
		if [[ "$initial_version" != "$INTERNAL_RESOLVE_PYTHON_VERSION" ]]; then
			dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: resolved version $initial_version -> $INTERNAL_RESOLVE_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: version $from_installed_version already installed"

	elif ! dpv_check_string_is_empty "$from_available"; then
		# Otherwise offer an available Python version that needs to be installed, if any matches
		dpv_kv_print "install_method" "$from_available"
		dpv_kv_print "version" "$from_available_version"

		dpv_internal_log "$from_available method selected"
		if [[ "$initial_version" != "$INTERNAL_RESOLVE_PYTHON_VERSION" ]]; then
			dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: resolved version $initial_version -> $INTERNAL_RESOLVE_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: version $from_available_version needs to be installed"

	else
		# If there are not matches among installed and available Python versions
		return 1
	fi
}

dpv_internal_scan_virtualenv() {
	#
	# Tries to find an existing virtualenv for the project
	# The virtualenvs directory has the following tree layout:
	#
	# + root (stored in variable: CFG_VIRTUALENVS_DIR)
	#  \
	#   - venv-dir-1
	#   - venv-dir-2
	#   + venv-dir-3
	#    \
	#     + dpv.cfg
	#      \
	#       |------ file format ------|
	#       |-------------------------|
	#       | path = /path/to/project |
	#       | version = 3.9.2         | --> this is the Python version
	#       | install_method = PYENV  |
	#       |-------------------------|
	#
	mkdir -p "$CFG_VIRTUALENVS_DIR"

	local found_virtualenv_dir="ø"
	local found_project_path
	local found_version
	local found_install_method

	# try to locate existing virtualenv
	while IFS= read -r file; do
		IFS=$'\n' read -d '' -r path version install_method <<<"$(dpv_internal_parse_virtualenv_config_file "$file" | dpv_kv_get "path" "version" "install_method")" || true

		if [[ "$path" == "$PWD" ]]; then
			if ! dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION" || [[ "$version" == "$INTERNAL_ARG_PYTHON_VERSION"* ]]; then
				if ! dpv_check_is_set "$found_virtualenv_dir"; then
					dpv_internal_log "found virtualenv: $(basename "$(dirname "$file")")"
					found_project_path=$path
					found_version=$version
					found_install_method=$install_method
					if [ "${ARG_TEMP:-}" == "1" ]; then
						found_virtualenv_dir=$(dpv_internal_mkdir_virtualenv_temporary)
					else
						found_virtualenv_dir=$(dirname "$file")
					fi
				else
					dpv_internal_log "found virtualenv: $(basename "$(dirname "$file")") (skipped)"
				fi
			fi
		fi
	done < <(find "$CFG_VIRTUALENVS_DIR" -name dpv.cfg -type f -mindepth 3 -maxdepth 3)

	if dpv_check_is_set "$found_virtualenv_dir"; then
		dpv_kv_print "virtualenv_dir" "$found_virtualenv_dir"
		dpv_kv_print "project_path" "$found_project_path"
		dpv_kv_print "version" "$found_version"
		dpv_kv_print "install_method" "$found_install_method"
	else
		return 1
	fi
}

dpv_internal_scan_python_version() {
	#
	# Tries to find the required Python version for a project in the following order:
	# 1. Check if a Python version was passed by argument
	# 2. Check if there is a runtime.txt file
	# 3. Check if there is a pyproject.toml file with a Python version
	# 4. Check if there is a Python version already installed with one of the install methods
	# 5. Check if there is a Python version available with one of the install methods
	#

	# use version provided by the user, if provided
	if dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION"; then
		dpv_kv_print "source" "command-line"
		dpv_kv_print "version" "$INTERNAL_ARG_PYTHON_VERSION"
		return
	fi

	# use version from runtime.txt, if available
	if [ -f "runtime.txt" ]; then
		dpv_kv_print "source" "runtime.txt"
		dpv_kv_print "version" "$(dpv_string_regex_replace "$(cat runtime.txt)" "^python\-" "")"
		return
	fi

	# use version from pyproject.toml, if available
	if [ -f "pyproject.toml" ]; then
		while IFS= read -r line; do
			if [[ "$line" =~ ^python\ *=\ *[\'\"][^0-9]*(.*)[\'\"] ]]; then
				dpv_kv_print "source" "pyproject.toml"
				dpv_kv_print "version" "${BASH_REMATCH[1]}"
				return
			fi
		done <"pyproject.toml"

		return
	fi

	# find installed version, if any
	local version_found="ø"
	while IFS= read -r line; do
		for install in $line; do
			dpv_${install}_load_installed_python_versions
			versions_var="INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS"
			if ! dpv_check_string_is_empty "${!versions_var}"; then
				while read -r version; do
					dpv_kv_print "source" "already installed with $(dpv_string_lowercase "$install")"
					dpv_kv_print "version" "$version"
					version_found=$version
					return
				done <<<"${!versions_var}"
			fi
		done
	done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"

	# find available version, if any
	if ! dpv_check_is_set "$version_found"; then
		while IFS= read -r line; do
			for install in $line; do
				dpv_${install}_load_available_python_versions
				versions_var="INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS"
				if ! dpv_check_string_is_empty "${!versions_var}"; then
					while read -r version; do
						dpv_kv_print "source" "can be installed with $(dpv_string_lowercase "$install")"
						dpv_kv_print "version" "$version"
						return
					done <<<"${!versions_var}"
				fi
			done
		done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"
	fi

	return 1
}

dpv_internal_parse_virtualenv_config_file() {
	local config_file="$1"

	local path=""
	local version=""
	local install_method=""

	while IFS= read -r line; do
		if [[ "$line" =~ ^path\ *=\ *(.*) ]]; then
			path="${BASH_REMATCH[1]}"
		elif [[ "$line" =~ ^version\ *=\ *(.*) ]]; then
			version="${BASH_REMATCH[1]}"
		elif [[ "$line" =~ ^install_method\ *=\ *(.*) ]]; then
			install_method="${BASH_REMATCH[1]}"
		fi
	done <"$config_file"

	dpv_kv_print "path" "$path"
	dpv_kv_print "version" "$version"
	dpv_kv_print "install_method" "$install_method"

	local missing
	if dpv_check_string_is_empty "$path"; then missing+=", path"; fi
	if dpv_check_string_is_empty "$version"; then missing+=", version"; fi
	if dpv_check_string_is_empty "$install_method"; then missing+=", install_method"; fi

	if ! dpv_check_string_is_empty "$missing"; then
		missing="$(dpv_string_lstrip 2 <<<"$missing")"
		dpv_internal_log "virtualenv config file missing: $missing (file: $config_file)"
		return 1
	fi
}

#
# Main function
#

dpv_main() {
	# VARS: External/Overridable
	DPV_VIRTUALENV_DIR="${DPV_VIRTUALENV_DIR:-ø}"

	CMD=""
	CMD_ARGS=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		--pyenv)
			ARG_USE_PYENV=1
			;;
		--homebrew | --brew)
			ARG_USE_HOMEBREW=1
			;;
		--list)
			CMD="list"
			;;
		--info)
			CMD="info"
			;;
		--help)
			CMD="help"
			;;
		--*)
			CMD_ARGS+=" $i"
			;;
		*)
			if [ "$CMD" == "" ]; then
				CMD="$i"
			else
				CMD_ARGS+=" $i"
			fi
			;;
		esac
	done

	CMD_ARGS=${CMD_ARGS:1} # drop leading space

	# must happen after ARG_ variables are parsed
	if [ "${ARG_USE_PYENV:-} ${ARG_USE_HOMEBREW:-}" == "1 1" ]; then
		echo "you should specify either --pyenv or --homebrew, not both"
		exit $ERR_INSTALL_METHOD_NOT_SELECTED
	elif [ "${ARG_USE_PYENV:-}" == "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="PYENV"
	elif [ "${ARG_USE_HOMEBREW:-}" == "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="HOMEBREW"
	fi

	dpv_internal_set_log_file

	case "$CMD" in
	internal-load-shell)
		unsafe_dpv_cmd_internal_load_shell
		;;

	list | --list | ls | -l)
		dpv_cmd_list | dpv_pipe_format_theme
		;;

	info)
		dpv_cmd_info | dpv_pipe_format_theme
		;;

	2* | 3* | 4*)
		if [[ "$CMD_ARGS" == *"--python"* ]]; then
			trap - EXIT
			echo "error: dpv cannot run \"dpv [version]\" with \"--python\" - use one or the other" | dpv_pipe_format_theme
			exit "$ERR_MAIN_INVALID_ARGUMENT"
		fi

		# shellcheck disable=2086
		unsafe_dpv_cmd_run_wrapper --python "$CMD" $CMD_ARGS
		;;

	run | "")
		# shellcheck disable=2086
		unsafe_dpv_cmd_run_wrapper $CMD_ARGS
		;;

	versions | -v)
		# shellcheck disable=2086
		dpv_cmd_versions $CMD_ARGS | dpv_pipe_format_theme
		;;

	drop | rm)
		dpv_cmd_drop
		;;

	help | --help | -h)
		dpv_cmd_help | dpv_pipe_format_theme
		;;

	*)
		echo "error: dpv invalid subcommand: $CMD" | dpv_pipe_format_theme
		exit "$ERR_MAIN_INVALID_ARGUMENT"
		;;

	esac
}

#
# Error-handling
#

dpv_error_handling() {
	case "$1" in

	"$ERR_MAIN_INVALID_ARGUMENT")
		echo "dpv - invalid argument"
		;;

	"$ERR_INSTALL_METHOD_NOT_SELECTED")
		echo "dpv - no installation method selected"
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		echo "dpv - failed to activate virtualenv $INTERNAL_VIRTUALENV_DIR"
		;;

	"$ERR_RUN_INVALID_ARGUMENT")
		echo "dpv - invalid argument passed to run"
		;;

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		echo "dpv - failed to determine python version for $PWD"
		;;

	"$ERR_NO_AVAILABLE_INSTALL_METHODS")
		echo "dpv - no installation methods available"
		;;

	"$ERR_CANNOT_RESOLVE_PYTHON_VERSION")
		echo "dpv - cannot resolve python version"
		;;

	"$ERR_VIRTUALENV_INSTALL_METHOD_NOT_AVAILABLE")
		echo "dpv - installation method defined by the virtualenv is not available"
		;;

	"$ERR_INSTALLATION_FAILED")
		echo "dpv - failed to install python version"
		;;

	esac

	dpv_internal_print_logs | dpv_pipe_format_theme
}

#
# Pyenv utils
#
dpv_PYENV_is_available() {
	hash "$CFG_PYENV_EXECUTABLE" 2>/dev/null
}

dpv_PYENV_exec() {
	"$CFG_PYENV_EXECUTABLE" "$@"
}

unsafe_dpv_PYENV_install() {
	while IFS= read -r python_version; do
		if [[ "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" == *"$python_version"* ]]; then
			continue
		fi
		echo "installing python $python_version using pyenv"
		local error=0
		(
			dpv_PYENV_exec install "$python_version" 2>&1 | dpv_pipe_quote
		) || error=1
		if [ $error -eq 0 ]; then
			echo done
		else
			echo failed
			dpv_internal_log "pyenv: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

unsafe_dpv_PYENV_get_python_executable() {
	local prefix="$(dpv_PYENV_exec prefix "$INTERNAL_VIRTUALENV_PYTHON_VERSION")"
	if [ "$?" -eq 0 ] && [ -d "$prefix" ]; then
		local cmd="$prefix/bin/python"
		if [ -x "$cmd" ]; then
			echo "$cmd"
			return
		fi
	fi
	exit "$ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE"
}

dpv_PYENV_load_installed_python_versions() {
	dpv_check_is_set "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="$(while IFS= read -r line; do
		cut -d/ -f1 <<<"$line" | uniq
	done < <(dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE versions --bare --skip-aliases") | dpv_pipe_sort_versions)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS"; then
		return 1
	fi
}

dpv_PYENV_load_available_python_versions() {
	dpv_check_is_set "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="$(
		dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE install --list" | grep '^ ' | tr -d ' ' | dpv_pipe_sort_versions
		echo
	)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS"; then
		return 1
	fi
}

dpv_PYENV_resolve_python_version() {
	while read -r line; do
		local resolved_version=""
		local available_version="none"
		local major_version="$(cut -d. -f1,2 <<<"$line")"

		dpv_PYENV_load_installed_python_versions
		while IFS= read -r version; do
			if [[ "$version" == "$line"* ]]; then
				resolved_version=$version
				break
			elif [[ "$version" == "$major_version"* ]]; then
				available_version=$version
			fi
		done <<<"$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS"

		dpv_PYENV_load_available_python_versions
		if dpv_check_string_is_empty "$resolved_version"; then
			while IFS= read -r version; do
				if [[ "$version" == "$line"* ]]; then
					resolved_version=$version
					break
				elif [[ "$version" == "$major_version"* ]]; then
					available_version=$version
				fi
			done <<<"$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS"
		fi

		if ! dpv_check_string_is_empty "$resolved_version"; then
			echo $resolved_version
		elif [[ "$available_version" != "none" ]]; then
			echo $available_version
		fi
	done
}

#
# Homebrew utils
#
dpv_HOMEBREW_is_available() {
	hash "$CFG_HOMEBREW_EXECUTABLE" 2>/dev/null
}

unsafe_dpv_HOMEBREW_install() {
	while IFS= read -r python_version; do
		if [[ "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" == *"$python_version"* ]]; then
			continue
		fi
		echo "installing python $python_version using homebrew"
		local error=0
		(
			HOMEBREW_NO_AUTO_UPDATE=1 dpv_HOMEBREW_exec install $(dpv_HOMEBREW_format_python_formula "$python_version") 2>&1 | dpv_pipe_quote
		) || error=1
		if [ $error -eq 0 ]; then
			echo done
		else
			echo failed
			dpv_internal_log "homebrew: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

dpv_HOMEBREW_exec() {
	"$CFG_HOMEBREW_EXECUTABLE" "$@"
}

dpv_unsafe_HOMEBREW_get_python_executable() {
	local cmd="$(dpv_HOMEBREW_exec --prefix $(dpv_HOMEBREW_format_python_formula "$INTERNAL_VIRTUALENV_PYTHON_VERSION") 2>/dev/null)"/libexec/bin/python
	if [ -x "$cmd" ]; then
		echo "$cmd"
	else
		exit "$ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE"
	fi
}

dpv_HOMEBREW_load_installed_python_versions() {
	dpv_check_is_set "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" && return

	dpv_HOMEBREW_load_available_python_versions

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE list" | grep 'python@' | cut -d@ -f2 | dpv_HOMEBREW_pipe_expand_python_version | dpv_pipe_sort_versions); then
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=""
		return 1
	fi
}

dpv_HOMEBREW_load_available_python_versions() {
	dpv_check_is_set "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" && return

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE search python"); then
		result=$(echo "$result" | grep -o 'python@[^ ]\+' | cut -d@ -f2 | dpv_HOMEBREW_pipe_expand_python_version | dpv_pipe_sort_versions)
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=""
		return 1
	fi
}

dpv_HOMEBREW_format_python_formula() {
	echo "python@$(cut -d. -f1,2 <<<"$1")"
}

dpv_HOMEBREW_resolve_python_version() {
	dpv_HOMEBREW_load_available_python_versions

	while read -r line; do
		local available_version="none"
		local major_version="$(cut -d. -f1,2 <<<"$line")"
		if [[ "$line" == "$major_version" ]]; then
			if [[ "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" == *"$major_version"* ]]; then
				dpv_HOMEBREW_pipe_expand_python_version <<<"$major_version"
				continue
			fi
		else
			local version=$(dpv_HOMEBREW_pipe_expand_python_version <<<"$major_version")
			if [[ "$version" == "$line" ]]; then
				echo $version
				continue
			fi
		fi
	done
}

dpv_HOMEBREW_pipe_expand_python_version() {
	while read -r line; do
		major_version="$(cut -d. -f1,2 <<<"$line")"
		formula_path="$(dpv_HOMEBREW_exec edit "$(dpv_HOMEBREW_format_python_formula "$major_version")" --print-path 2>/dev/null)" || return 1
		while IFS= read -r version; do
			echo $version
			break
		done < <(grep -o "$major_version\.[0-9]\+[a-z]*" "$formula_path")
	done
}

#
# Internals
#
dpv_internal_mkdir_virtualenv() {
	local dirname="$CFG_VIRTUALENVS_DIR/$INTERNAL_VIRTUALENV_PYTHON_VERSION/$(basename "$PWD")-$INTERNAL_VIRTUALENV_PYTHON_VERSION"
	mkdir -p "$dirname"
	printf $dirname
}

dpv_internal_mkdir_virtualenv_temporary() {
	local dirname="${TMPDIR:-/tmp/}$(basename "$PWD")-$INTERNAL_VIRTUALENV_PYTHON_VERSION.tmpXXXXX"
	mktemp -d "$dirname"
	printf $dirname
}

dpv_internal_set_log_file() {
	dpv_check_is_set "$INTERNAL_LOG_FILE" && return

	INTERNAL_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
}

unsafe_dpv_internal_set_available_install_methods() {
	#
	# Unsafe:
	# - unsafe_dpv_internal_set_available_install_methods:
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	dpv_check_is_set "$INTERNAL_AVAILABLE_INSTALL_METHODS" && return

	INTERNAL_AVAILABLE_INSTALL_METHODS="$(while IFS= read -r install; do
		if [[ dpv_${install}_is_available ]]; then
			echo $install
		fi
	done < <(dpv_string_uppercase "$CFG_PREFERRED_INSTALL_METHODS"))"

	if dpv_check_string_is_empty "$INTERNAL_AVAILABLE_INSTALL_METHODS"; then
		exit "$ERR_NO_AVAILABLE_INSTALL_METHODS"
	fi
}

dpv_internal_run_command_log_failure() {
	tmpfile=$(mktemp)

	# shellcheck disable=SC2068
	bash -c "$@" &>"$tmpfile"
	if [ "$?" -eq 0 ]; then
		cat "$tmpfile"
		return 0
	else
		dpv_internal_log "failed to run command: $*"
		echo -e "$(dpv_pipe_quote <"$tmpfile")" >>"$INTERNAL_LOG_FILE"
		return 1
	fi
}

dpv_internal_log() {
	echo -e "$@" >>"$INTERNAL_LOG_FILE"
}

dpv_internal_pipe_format_python_versions() {
	local install_method="$1"
	local options="${2:-}"

	local installed_versions_var="INTERNAL_${install_method}_INSTALLED_PYTHON_VERSIONS"
	local installed_versions=${!installed_versions_var}

	if [[ " $options " == *" --all "* ]]; then
		while IFS= read -r line; do
			# check if installed
			for version in $installed_versions; do
				if [[ "$version" == "$line" ]]; then
					echo "$version*"
					continue 2
				fi
			done

			echo $line
		done

	else
		local skip=""

		while IFS= read -r line; do
			local major_version="$(dpv_pipe_format_major_version <<<"$line")"
			local fallback_installed=""

			# check if minor installed
			for version in $installed_versions; do
				if [[ "$version" == "$line" ]]; then
					if [[ " $skip " != *" $line "* ]]; then
						skip+=" $major_version "
						echo "$version*"
					fi
					continue 2
				elif [[ "$version" == "$major_version."* ]]; then
					fallback_installed="$version"
				fi
			done

			if [[ " $skip " == *" $major_version "* ]]; then
				continue
			else
				skip+=" $major_version "
			fi

			# fallback
			if [[ "$fallback_installed" != "" ]]; then
				skip+=" $fallback_installed "
				echo "$fallback_installed*"
				continue
			fi

			# check if mainstream
			if [[ ! "$line" =~ ^3.([789]|1[0-9]) ]] || [[ "$line" == *"rc"* ]] || [[ "$line" == *"dev"* ]]; then
				# Skip non-mainstream versions
				continue
			fi

			echo $line

		done
	fi
}

#
# General utils
#
dpv_pipe_sort_versions() {
	sort --version-sort --reverse
}

dpv_pipe_format_nl_to_space() {
	echo -n "$(cat)" | tr '\n' ' '
}

dpv_pipe_format_major_version() {
	cut -d. -f1,2
}

dpv_pipe_format_theme() {
	"$CFG_THEME"
}

dpv_pipe_quote() {
	local prefix="${1:->}"
	sed "s/^/  $prefix /"
}

dpv_check_file_is_empty() {
	# -s :: Size is > 0 bytes
	! [ -s "$1" ]
}

dpv_check_string_is_empty() {
	# -z :: String is empty
	[[ -z "$1" ]]
}

dpv_check_is_set() {
	# "ø" :: Special value for empty/unset
	[[ "$1" != "ø" ]]
}

dpv_string_lstrip() {
	local remove_after_including="$(($1 + 1))"
	cut -c "$remove_after_including"-
}

dpv_string_uppercase() {
	tr '[:lower:]' '[:upper:]' <<<"$1"
}

dpv_string_lowercase() {
	tr '[:upper:]' '[:lower:]' <<<"$1"
}

dpv_string_regex_replace() {
	local string="$1"
	local from="$2"
	local to="$3"

	sed "s/$from/$to/" <<<"$string"
}

dpv_string_count_characters() {
	local string="$1"
	local char="$2"
	echo "$(($(tr -cd "$char" <<<"$string" | wc -c) + 0))"
}

dpv_kv_parse_key() {
	# https://stackoverflow.com/a/20348190
	echo ${@%% = *}
}

dpv_kv_parse_val() {
	# https://stackoverflow.com/a/15149278
	echo ${@#* = }
}

dpv_kv_print() {
	echo "$1" = "${@:2}"
}

dpv_kv_get() {
	local get_keys=""
	while [[ "$#" -gt 0 ]]; do
		get_keys+=" $1 "
		shift
	done

	while IFS= read -r line; do
		key="$(dpv_kv_parse_key "$line")"
		if [[ "$get_keys" == *" $key "* ]]; then
			declare "_kv_$key"="$(dpv_kv_parse_val "$line")"
		fi
	done

	for key in $get_keys; do
		key="_kv_$key"
		echo "${!key:-ø}"
	done
}

# https://stackoverflow.com/a/28776166
(return 0 2>/dev/null) || dpv_main "$@"
