#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv instrument)"
#
# Usage:
#   Go to the directory of the project and call "dpv"
#
set -e

function cmd_help() {
	_load_config_vars

	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv             - installs virtualenv for the current directory"
	echo "  dpv help        - display these instructions"
	echo "  dpv list        - lists virtualenvs managed by dpv"
	echo "  dpv where       - display the virtualenv directory"
	echo "  dpv version     - display version"
	echo "  dpv instrument  - instruments dpv"
	echo "  dpv run [cmd]   - runs command inside virtualenv [default: \$SHELL]"
	echo
	echo "aliases:"
	echo "  dpv -h / dpv help"
	echo "  dpv -v / dpv version"
	echo "  dpv -l / dpv ls / dpv list"
	echo
	echo "global arguments:"
	echo "  -q / --quiet    - do not show logs"
	echo
}

function cmd_version() {
	_load_config_vars
	echo "$CFG_VERSION"
}

function cmd_where() {
	_load_config_vars
	_load_python_vars
	echo "$VENV_DIR"
}

function cmd_instrument() {
	trap - EXIT

	# https://stackoverflow.com/a/13864829
	if [ -n "${DPV_SHELL+x}" ]; then
		_load_config_vars
		_load_python_vars

		_print_venv_activate
	fi
}

function cmd_list() {
	case "$1" in
	--plain | *)
		_load_config_vars
		_plain_list
		;;
	esac
}

function cmd_run() {
	_load_config_vars
	_load_python_vars

	if [ ! -d "$VENV_DIR" ]; then
		_create_venv_if_not_exists
	fi

	_run_command "$@"
}

function err_detecting_python_version() {
	_log "- failed to determine python version for $PWD"

	_print_exit_shell
}

function err_activate_virtualenv() {
	_log "- failed to activate virtualenv $VENV_DIR"

	_print_exit_shell
}

function __main() {
	trap '_error_handling $?' EXIT

	CMD=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		-q | --quiet)
			ARG_QUIET=1
			shift
			;;
		*)
			if [ "$CMD" == "" ]; then
				CMD="$i"
				shift
			else
				break
			fi
			;;
		esac
	done

	case "$CMD" in
	where)
		cmd_where
		;;

	instrument)
		cmd_instrument
		;;

	list | ls | -l)
		cmd_list "${1:--plain}"
		;;

	run | "")
		cmd_run "$@"
		;;

	version | -v)
		cmd_version
		;;

	help | -h)
		cmd_help
		;;

	*)
		trap - EXIT
		echo "dpv invalid subcommand: $CMD"
		exit 1
		;;

	esac
}

ERR_CANNOT_DETERMINE_PYTHON_VERSION=2
ERR_CANNOT_ACTIVATE_VIRTUALENV=3

function _error_handling() {
	case "$1" in

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		err_detecting_python_version
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		err_activate_virtualenv
		;;

	esac

	if [ -z "${DPV_INSTRUMENT+x}" ]; then
		_print_logs
	fi
}

function _run_command() {
	if [ -n "${DPV_SHELL+x}" ]; then
		trap - EXIT
		exit 0
	fi

	if [ "$#" -eq 0 ]; then
		_print_logs
		DPV_SHELL=1 "$SHELL"
		trap - EXIT
	else
		PATH=$VENV_DIR/bin:$PATH "$@"
	fi
}

function _load_config_vars() {
	CFG_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
	CFG_INSTALL_METHOD="${DPV_INSTALL_METHOD}"
	CFG_QUIET="${ARG_QUIET:-${DPV_QUIET:-0}}"

	# https://stackoverflow.com/a/677212
	if hash pyenv 2>/dev/null; then
		if [ "$CFG_INSTALL_METHOD" == "pyenv" ] || [ "$CFG_INSTALL_METHOD" == "" ]; then
			CFG_INSTALL_METHOD="pyenv"
			_log "- pyenv is installed (preferred)"
		else
			_log "- pyenv is installed but will not be used"
		fi
	fi
	if hash brew 2>/dev/null; then
		if [ "$CFG_INSTALL_METHOD" == "homebrew" ] || [ "$CFG_INSTALL_METHOD" == "" ]; then
			CFG_INSTALL_METHOD="homebrew"
			_log "- homebrew is installed (preferred)"
		else
			_log "- homebrew is installed but will not be used"
		fi
	fi

	CFG_VERSION="1.0.0"
	CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
	CFG_VENVS_DIR="$CFG_DIR/virtualenvs"

	mkdir -p "$CFG_VENVS_DIR"
}

function _load_python_vars() {
	PY_VERSION=$(_get_python_version)
	PY_PREFIX=$(_get_python_prefix)

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		PY_EXECUTABLE="$PY_PREFIX/bin/python"
		;;
	homebrew)
		PY_EXECUTABLE="$PY_PREFIX/bin/python3"
		;;
	esac

	VENV_DIR=$CFG_VENVS_DIR/$PY_VERSION/$(basename "$PWD")-$PY_VERSION
}

function _get_python_version() {
	local python_version
	if [ -f "runtime.txt" ]; then
		python_version=$(sed 's/^python\-//' <runtime.txt)
		_log "- parsed python version $python_version from runtime.txt file"
	else
		_log "- cannot find $PWD/runtime.txt file"
		exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
	fi

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		_log "- checking installation of $python_version with pyenv"
		_log "$(sed s'/^/  > /' <(pyenv install "$python_version" --skip-existing 2>&1))"
		_log "  ok"
		;;
	homebrew)
		if [ "$(_util_count_char "$python_version" '.')" -gt 1 ]; then
			python_version=$(cut -d. -f1,2 <(echo "$python_version"))
			_log "- homebrew only supports 3.y python versions, using $python_version"
		fi
		_log "- checking installation of $python_version with homebrew"
		_log "$(sed 's/^/  > /' <(HOMEBREW_NO_AUTO_UPDATE=1 brew install "python@$python_version" 2>&1))"
		_log "  ok"
		;;
	esac

	echo "$python_version"
}

function _get_python_prefix() {
	case "$CFG_INSTALL_METHOD" in
	pyenv)
		pyenv prefix "$PY_VERSION"
		;;
	homebrew)
		brew --prefix "python@$PY_VERSION"
		;;
	esac
}

function _create_venv_if_not_exists() {
	if [ ! -d "$VENV_DIR" ]; then
		"$PY_EXECUTABLE" -m venv "$VENV_DIR"
	fi
}

function _print_venv_activate() {
	echo "source $VENV_DIR/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
}

function _plain_list() {
	find "$CFG_VENVS_DIR" -maxdepth 2 -mindepth 2
}

function _print_exit_shell() {
	if [ -n "${DPV_SHELL+x}" ]; then
		echo "unset DPV_SHELL"
		echo "exit 1"
	fi
}

function _log() {
	echo "$@" >>"$CFG_LOG_FILE"
}

function _print_logs() {
	if [[ "$CFG_QUIET" -eq 0 ]]; then
		echo
		echo "logs:"
		sed 's/^/  /' <"$CFG_LOG_FILE"
		echo
	fi
}

function _util_count_char() {
	echo "$1" | tr -cd "$2" | wc -c
}

__main "$@"
