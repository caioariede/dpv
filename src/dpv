#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv internal-instrument)"
#
# Usage:
#   Go to the directory of the project and call "dpv"
#
# Code guidelines:
#
# 1. Internal commands should be prefixed with "internal-"
# 2. Commands are displayed in the usage by alphabetical order
# 3. There are four kinds of functions:
#    - command function
#    - command variant functions
#    - initialization functions
#    - short-hand functions
#    - utility functions
# 4. Command functions should be named "cmd_{command name}"
# 5. Command variants functions should be named "cmd_{command name}_{variant}"
# 6. Initialization functions should be named "init_{name}"
# 7. Short-hand functions differently than utilities are not pure
# 8. Utilities are "pure" functions and should be prefixed with "__"
# 9. Exit codes should be stored in constants prefixed with "ERR_"

set -eu
set -o pipefail

#
# Error exit codes
#

ERR_MAIN_INVALID_ARGUMENT=131
ERR_INSTALL_METHOD_NOT_SELECTED=132
ERR_CANNOT_ACTIVATE_VIRTUALENV=133
ERR_RUN_INVALID_ARGUMENT=134
ERR_CANNOT_DETERMINE_PYTHON_VERSION=135
ERR_NO_AVAILABLE_INSTALL_METHODS=136
ERR_CANNOT_RESOLVE_PYTHON_VERSION=137
ERR_VENV_INSTALL_METHOD_NOT_AVAILABLE=138
ERR_INSTALLATION_FAILED=139

# VARS: Configuration
CFG_VERSION="0.9.2"
CFG_THEME="${DPV_THEME:-cat}"
CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
CFG_VENVS_DIR="$CFG_DIR/virtualenvs"
CFG_PYENV_EXECUTABLE="${PYENV_EXECUTABLE:-pyenv}"
CFG_HOMEBREW_EXECUTABLE="${HOMEBREW_EXECUTABLE:-brew}"
CFG_PREFERRED_INSTALL_METHODS="pyenv homebrew"

# VARS: Internal
INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="ø"
INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="ø"
INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS="ø"
INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS="ø"
INTERNAL_AVAILABLE_INSTALL_METHODS="ø"
INTERNAL_LOG_FILE="ø"
INTERNAL_SCAN_PYTHON_VERSION="ø"
INTERNAL_SCAN_PYTHON_VERSION_SOURCE="ø"
INTERNAL_ARG_PYTHON_VERSION="ø"
INTERNAL_VENV_INSTALL_METHOD="ø"
INTERNAL_VENV_PYTHON_VERSION="ø"

#
# Command functions
#
# These functions are called by the main() function
# Unsafe commands should set a trap to the error_handling() function
#

cmd_help() {
	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv [python version]"
	echo
	echo "commands:"
	echo "  dpv help             - display these instructions"
	echo "  dpv info             - display information about the current virtualenv"
	echo "  dpv list             - list virtualenvs created with dpv"
	echo "  dpv run [command]    - run command inside virtualenv [default: \$SHELL]"
	echo "    --python [version] - specify python version"
	echo "    --temp             - use a temporary virtualenv"
	echo "  dpv versions         - display available python versions"
	echo "    --all              - display extended list of available python versions"
	echo "  dpv drop             - remove current virtualenv"
	echo
	echo "global arguments:"
	echo "  --pyenv              - use pyenv"
	echo "  --homebrew           - use homebrew"
	echo
	echo "aliases:"
	echo "  dpv run / dpv"
	echo "  dpv [version] / dpv run --python [version]"
	echo "  dpv info / dpv (when virtualenv is activated)"
	echo "  dpv help / --help / -h"
	echo "  dpv list / --list / ls / -l"
	echo "  dpv versions / -v"
	echo "  dpv versions --all / -a"
	echo
	echo "config:"
	echo "  CFG_VENVS_DIR=$CFG_VENVS_DIR"
	echo "  CFG_THEME=$CFG_THEME"
	echo "  CFG_DIR=$CFG_DIR"
	echo "  CFG_PYENV_EXECUTABLE=$CFG_PYENV_EXECUTABLE"
	echo "  CFG_HOMEBREW_EXECUTABLE=$CFG_HOMEBREW_EXECUTABLE"
	echo "  CFG_PREFERRED_INSTALL_METHODS=$CFG_PREFERRED_INSTALL_METHODS"
}

cmd_versions() {
	trap 'error_handling $?' EXIT

	case "${1:-}" in
	--installed)
		echo "command: installed python versions"
		echo

		pyenv_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" | dpv_format_highlight_versions "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" | dpv_format_nl_to_space)

		homebrew_load_installed_python_versions
		echo "homebrew:" $(echo "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" | dpv_format_highlight_versions "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" | dpv_format_nl_to_space)

		;;

	--all | -a)
		echo "command: available python versions (extended list)"
		echo

		pyenv_load_available_python_versions
		pyenv_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" | dpv_format_highlight_versions "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" | dpv_format_nl_to_space)

		homebrew_load_available_python_versions
		homebrew_load_installed_python_versions
		echo "homebrew:" $(echo "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" | dpv_format_highlight_versions "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" | dpv_format_nl_to_space)
		;;

	"")
		echo "command: available python versions"
		echo

		pyenv_load_available_python_versions
		pyenv_load_installed_python_versions
		echo "pyenv:" $(echo "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" | dpv_filter_mainstream_version | dpv_filter_unique_major_versions | dpv_format_highlight_versions "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" | dpv_format_nl_to_space)

		homebrew_load_available_python_versions
		homebrew_load_installed_python_versions
		echo "homebrew: $(echo "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" | dpv_filter_mainstream_version | dpv_filter_unique_major_versions | dpv_format_highlight_versions "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" | dpv_format_nl_to_space)"
		;;

	*)
		echo "error: unknown argument $1"
		;;

	esac
}

cmd_drop() {
	echo "command: drop virtualenv"
	echo

	if dpv_check_is_set "$DPV_VENV_DIR"; then
		rm -rf "$DPV_VENV_DIR"
		echo "dropped"
	else
		echo "error: virtualenv not activated"
		return
	fi
}

unsafe_cmd_internal_instrument() {
	#
	# Unsafe:
	# - unsafe_cmd_internal_instrument:
	#   - ERR_CANNOT_ACTIVATE_VIRTUALENV
	#
	dpv_check_is_set "$DPV_VENV_DIR" || return

	echo "source $DPV_VENV_DIR/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
}

cmd_list() {
	echo "command: list of virtualenvs"
	echo

	find "$CFG_VENVS_DIR" -maxdepth 2 -mindepth 2 | sort
}

cmd_info() {
	trap 'error_handling $?' EXIT

	unsafe_print_info
}

unsafe_wrap_cmd_run() {
	#
	# Unsafe:
	# - unsafe_cmd_run:
	#   - ERR_RUN_INVALID_ARGUMENT
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	#
	if dpv_check_is_set "$DPV_VENV_DIR"; then
		cmd_info | dpv_format_theme
	else
		unsafe_cmd_run $*
	fi
}

unsafe_cmd_run() {
	#
	# Unsafe:
	# - unsafe_cmd_run:
	#   - ERR_RUN_INVALID_ARGUMENT
	# - unsafe_init_virtualenv_vars:
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	# - unsafe_print_info
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	trap 'error_handling $?' EXIT

	CMD=""

	while [[ "$#" -gt 0 ]]; do
		if [ "$CMD" == "" ]; then
			case "$1" in
			--python)
				shift
				INTERNAL_ARG_PYTHON_VERSION="$1"
				shift
				;;
			--tmp | --temp)
				ARG_TEMP=1
				shift
				;;
			-*)
				echo "error: invalid argument: $1"
				exit "$ERR_RUN_INVALID_ARGUMENT"
				;;
			*)
				CMD=" $1"
				shift
				;;
			esac
		else
			CMD+=" $1"
			shift
		fi
	done

	CMD=${CMD:1}

	unsafe_init_virtualenv_vars

	trap - EXIT
	if [ "$CMD" == "" ]; then
		DPV_VENV_DIR=$INTERNAL_VENV_DIR unsafe_print_info
		DPV_VENV_DIR=$INTERNAL_VENV_DIR "$SHELL"
	else
		PATH=$INTERNAL_VENV_DIR/bin:$PATH $CMD
	fi
}

#
# Initialization functions
#

unsafe_init_virtualenv_vars() {
	#
	# Tries to find an existing virtualenv matching the following:
	# 1. The directory path
	# 2. The Python version, if provided as an argument
	#
	# If not match, a Python version is asked to the user
	# Once a Python version is provided, look for the closest match:
	# 1. Already installed by one of the installation methods
	# 2. Available by one of the installation methods
	# 3. Error out (ERR_CANNOT_RESOLVE_PYTHON_VERSION)
	#
	# Loads:
	# - INTERNAL_VENV_PYTHON_VERSION: The version resolved for the virtualenv
	# - INTERNAL_VENV_INSTALL_METHOD: The installaton method resolved for the virtualenv
	# - INTERNAL_VENV_DIR: The directory path for the virtualenv
	#
	# Unsafe:
	# - unsafe_init_virtualenv_vars:
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	# - unsafe_dpv_internal_set_available_install_methods:
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	mkdir -p "$CFG_VENVS_DIR"

	# try to locate existing virtualenv
	while IFS= read -r file; do
		local path
		local version
		local install_method
		while IFS= read -r line; do
			if [[ "$line" =~ ^path\ *=\ *(.*) ]]; then
				path="${BASH_REMATCH[1]}"
			elif [[ "$line" =~ ^version\ *=\ *(.*) ]]; then
				version="${BASH_REMATCH[1]}"
			elif [[ "$line" =~ ^install_method\ *=\ *(.*) ]]; then
				install_method="${BASH_REMATCH[1]}"
			fi
		done <"$file"
		if [[ "$path" == "$PWD" ]]; then
			if ! dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION" || [[ "$version" == "$INTERNAL_ARG_PYTHON_VERSION"* ]]; then
				if ! dpv_check_is_set "$INTERNAL_VENV_PYTHON_VERSION"; then
					dpv_internal_log "found virtualenv: $(basename "$(dirname "$file")") (selected first match)"
					INTERNAL_VENV_PYTHON_VERSION=$version
					INTERNAL_VENV_INSTALL_METHOD=$install_method
					if [ "${ARG_TEMP:-}" == "1" ]; then
						INTERNAL_VENV_DIR=$(dpv_internal_mktemp_venv_dir)
					else
						INTERNAL_VENV_DIR=$(dirname "$file")
					fi
				else
					dpv_internal_log "found virtualenv: $(basename "$(dirname "$file")") (skipped)"
				fi
			fi
		fi
	done < <(find "$CFG_VENVS_DIR" -name dpv.cfg -type f -mindepth 3 -maxdepth 3)

	if dpv_check_is_set "$INTERNAL_VENV_PYTHON_VERSION"; then
		return
	fi

	# virtualenv was not located
	unsafe_dpv_internal_scan_python_version
	read -rp "python version [selected: $INTERNAL_SCAN_PYTHON_VERSION source: $INTERNAL_SCAN_PYTHON_VERSION_SOURCE]: " INTERNAL_VENV_PYTHON_VERSION
	INTERNAL_VENV_PYTHON_VERSION=${INTERNAL_VENV_PYTHON_VERSION:-$INTERNAL_SCAN_PYTHON_VERSION}

	unsafe_dpv_internal_set_available_install_methods

	local version="$INTERNAL_VENV_PYTHON_VERSION"
	local from_installed=""
	local from_installed_version=""
	local from_available=""
	local from_available_version=""
	while IFS= read -r line; do
		for install in $line; do
			${install}_load_installed_python_versions
			${install}_load_available_python_versions

			local installed_versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS")
			local available_versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS")

			local installed_versions=${!installed_versions_var}
			local available_versions=${!available_versions_var}

			resolved_version=$(${install}_resolve_python_version <<<"$INTERNAL_VENV_PYTHON_VERSION")
			if dpv_check_string_is_empty "$resolved_version"; then
				continue
			fi

			if [[ "$installed_versions" == *"$resolved_version"* ]]; then
				from_installed="$install"
				from_installed_version="$resolved_version"
				break 2
			elif [[ "$available_versions" == *"$resolved_version"* ]]; then
				from_available="$install"
				from_available_version="$resolved_version"
			fi
		done
	done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"

	if ! dpv_check_string_is_empty "$from_installed"; then
		INTERNAL_VENV_INSTALL_METHOD=$from_installed
		INTERNAL_VENV_PYTHON_VERSION=$from_installed_version

		dpv_internal_log "$from_installed method selected"
		if [[ "$version" != "$INTERNAL_VENV_PYTHON_VERSION" ]]; then
			dpv_internal_log "$INTERNAL_VENV_INSTALL_METHOD: resolved version $version -> $INTERNAL_VENV_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_VENV_INSTALL_METHOD: version $from_installed_version already installed"

	elif ! dpv_check_string_is_empty "$from_available"; then
		INTERNAL_VENV_INSTALL_METHOD=$from_available
		INTERNAL_VENV_PYTHON_VERSION=$from_available_version

		dpv_internal_log "$from_available method selected"
		if [[ "$version" != "$INTERNAL_VENV_PYTHON_VERSION" ]]; then
			dpv_internal_log "$INTERNAL_VENV_INSTALL_METHOD: resolved version $version -> $INTERNAL_VENV_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_VENV_INSTALL_METHOD: version $from_available_version needs to be installed"
	else
		exit "$ERR_CANNOT_RESOLVE_PYTHON_VERSION"
	fi

	if [ "${ARG_TEMP:-}" == "1" ]; then
		INTERNAL_VENV_DIR=$(dpv_internal_mktemp_venv_dir)
	else
		INTERNAL_VENV_DIR=${INTERNAL_VENV_DIR:-$CFG_VENVS_DIR/$INTERNAL_VENV_PYTHON_VERSION/$(basename "$PWD")-$INTERNAL_VENV_PYTHON_VERSION}
	fi

	# install Python version
	${INTERNAL_VENV_INSTALL_METHOD}_install <<<"$INTERNAL_VENV_PYTHON_VERSION"

	# create virtualenv
	INTERNAL_VENV_PY_EXECUTABLE=$(${install}_get_python_executable "$INTERNAL_VENV_PYTHON_VERSION")

	"$INTERNAL_VENV_PY_EXECUTABLE" -m venv "$INTERNAL_VENV_DIR"
	echo -e "path = $PWD\nversion = $INTERNAL_VENV_PYTHON_VERSION\ninstall_method = $INTERNAL_VENV_INSTALL_METHOD" >"$INTERNAL_VENV_DIR/dpv.cfg"
	dpv_internal_log "created new virtualenv: $(basename "$INTERNAL_VENV_DIR")"
}

unsafe_dpv_internal_scan_python_version() {
	#
	# Tries to find the required Python version for a project in the following order:
	# 1. Check if a Python version was passed by argument
	# 2. Check if there is a runtime.txt file
	# 3. Check if there is a pyproject.toml file with a Python version
	# 4. Check if there is a Python version already installed with one of the install methods
	# 5. Check if there is a Python version available with one of the install methods
	#
	# Unsafe:
	# - unsafe_dpv_internal_set_available_install_methods
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	dpv_check_is_set "$INTERNAL_SCAN_PYTHON_VERSION_SOURCE" && return

	# use version provided by the user, if provided
	if dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION"; then
		INTERNAL_SCAN_PYTHON_VERSION_SOURCE="command-line"
		INTERNAL_SCAN_PYTHON_VERSION="$INTERNAL_ARG_PYTHON_VERSION"

		return
	fi

	# use version from runtime.txt, if available
	if [ -f "runtime.txt" ]; then
		INTERNAL_SCAN_PYTHON_VERSION_SOURCE="runtime.txt"
		INTERNAL_SCAN_PYTHON_VERSION=$(sed 's/^python\-//' <runtime.txt)

		return
	fi

	# use version from pyproject.toml, if available
	if [ -f "pyproject.toml" ]; then
		while IFS= read -r line; do
			if [[ "$line" =~ ^python\ *=\ *[\'\"][^0-9]*(.*)[\'\"] ]]; then
				INTERNAL_SCAN_PYTHON_VERSION_SOURCE="pyproject.toml"
				INTERNAL_SCAN_PYTHON_VERSION="${BASH_REMATCH[1]}"

				return
			fi
		done <"pyproject.toml"

		return
	fi

	unsafe_dpv_internal_set_available_install_methods

	# find installed version, if any
	while IFS= read -r line; do
		for install in $line; do
			${install}_load_installed_python_versions
			versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS")
			if ! dpv_check_string_is_empty "${!versions_var}"; then
				while read -r version; do
					INTERNAL_SCAN_PYTHON_VERSION=$version
					INTERNAL_SCAN_PYTHON_VERSION_SOURCE="already installed with $install"
					return
				done <<<"${!versions_var}"
			fi
		done
	done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"

	# find available version, if any
	if ! dpv_check_is_set "$INTERNAL_SCAN_PYTHON_VERSION"; then
		while IFS= read -r line; do
			for install in $line; do
				${install}_load_available_python_versions
				versions_var=$(tr '[:lower:]' '[:upper:]' <<<"INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS")
				if ! dpv_check_string_is_empty "${!versions_var}"; then
					while read -r version; do
						INTERNAL_SCAN_PYTHON_VERSION=$version
						INTERNAL_SCAN_PYTHON_VERSION_SOURCE="can be installed with $install"
						return
					done <<<"${!versions_var}"
				fi
			done
		done <<<"$INTERNAL_AVAILABLE_INSTALL_METHODS"
	fi

	exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
}

#
# Main function
#

main() {
	#
	# Unsafe:
	# - main:
	#   - ERR_MAIN_INVALID_ARGUMENT
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	# - unsafe_cmd_internal_instrument:
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	#   - ERR_CANNOT_ACTIVATE_VIRTUALENV
	# - unsafe_wrap_cmd_run:
	#   - ERR_RUN_INVALID_ARGUMENT
	#   - ERR_CANNOT_DETERMINE_PYTHON_VERSION
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#   - ERR_CANNOT_RESOLVE_PYTHON_VERSION
	#   - ERR_INSTALL_METHOD_NOT_SELECTED
	#

	# VARS: External/Overridable
	DPV_VENV_DIR="${DPV_VENV_DIR:-ø}"

	CMD=""
	CMD_ARGS=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		--pyenv)
			ARG_USE_PYENV=1
			;;
		--homebrew | --brew)
			ARG_USE_HOMEBREW=1
			;;
		--list)
			CMD="list"
			;;
		--info)
			CMD="info"
			;;
		--help)
			CMD="help"
			;;
		--*)
			CMD_ARGS+=" $i"
			;;
		*)
			if [ "$CMD" == "" ]; then
				CMD="$i"
			else
				CMD_ARGS+=" $i"
			fi
			;;
		esac
	done

	CMD_ARGS=${CMD_ARGS:1} # drop leading space

	# must happen after ARG_ variables are parsed
	if [ "${ARG_USE_PYENV:-} ${ARG_USE_HOMEBREW:-}" == "1 1" ]; then
		echo "you should specify either --pyenv or --homebrew, not both"
		exit $ERR_INSTALL_METHOD_NOT_SELECTED
	elif [ "${ARG_USE_PYENV:-}" == "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="pyenv"
	elif [ "${ARG_USE_HOMEBREW:-}" == "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="homebrew"
	fi

	dpv_internal_set_log_file

	case "$CMD" in
	internal-instrument)
		unsafe_cmd_internal_instrument
		;;

	list | --list | ls | -l)
		cmd_list | dpv_format_theme
		;;

	info)
		cmd_info | dpv_format_theme
		;;

	2* | 3* | 4*)
		if [[ "$CMD_ARGS" == *"--python"* ]]; then
			trap - EXIT
			echo "error: dpv cannot run \"dpv [version]\" with \"--python\" - use one or the other" | dpv_format_theme
			exit "$ERR_MAIN_INVALID_ARGUMENT"
		fi

		# shellcheck disable=2086
		unsafe_wrap_cmd_run --python "$CMD" $CMD_ARGS
		;;

	run | "")
		# shellcheck disable=2086
		unsafe_wrap_cmd_run $CMD_ARGS
		;;

	versions | -v)
		# shellcheck disable=2086
		cmd_versions $CMD_ARGS | dpv_format_theme
		;;

	drop | rm)
		cmd_drop
		;;

	help | --help | -h)
		cmd_help | dpv_format_theme
		;;

	*)
		echo "error: dpv invalid subcommand: $CMD" | dpv_format_theme
		exit "$ERR_MAIN_INVALID_ARGUMENT"
		;;

	esac
}

#
# Error-handling
#

error_handling() {
	case "$1" in

	"$ERR_MAIN_INVALID_ARGUMENT")
		echo "dpv - invalid argument"
		;;

	"$ERR_INSTALL_METHOD_NOT_SELECTED")
		echo "dpv - no installation method selected"
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		echo "dpv - failed to activate virtualenv $INTERNAL_VENV_DIR"
		;;

	"$ERR_RUN_INVALID_ARGUMENT")
		echo "dpv - invalid argument passed to run"
		;;

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		echo "dpv - failed to determine python version for $PWD"
		;;

	"$ERR_NO_AVAILABLE_INSTALL_METHODS")
		echo "dpv - no installation methods available"
		;;

	"$ERR_CANNOT_RESOLVE_PYTHON_VERSION")
		echo "dpv - cannot resolve python version"
		;;

	"$ERR_VENV_INSTALL_METHOD_NOT_AVAILABLE")
		echo "dpv - installation method defined by the virtualenv is not available"
		;;

	"$ERR_INSTALLATION_FAILED")
		echo "dpv - failed to install python version"
		;;

	esac

	dpv_internal_print_logs | dpv_format_theme
}

#
# Short-hand functions
#

unsafe_print_info() {
	#
	# Unsafe:
	# - unsafe_dpv_internal_set_available_install_methods
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	echo "dpv - $(basename "$DPV_VENV_DIR") activated"

	unsafe_dpv_internal_scan_python_version
	dpv_internal_print_logs | dpv_format_theme
}

#
# Pyenv utils
#
pyenv_is_available() {
	hash "$CFG_PYENV_EXECUTABLE" 2>/dev/null
}

pyenv_exec() {
	"$CFG_PYENV_EXECUTABLE" "$@"
}

pyenv_install() {
	while IFS= read -r python_version; do
		if [[ "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" == *"$python_version"* ]]; then
			continue
		fi
		echo "installing python $python_version using pyenv"
		local error=0
		(
			pyenv_exec install "$python_version" 2>&1 | sed 's/^/  > /'
		) || error=1
		if [ $error -eq 0 ]; then
			echo done
		else
			echo failed
			dpv_internal_log "pyenv: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

pyenv_get_python_executable() {
	echo $(pyenv_exec prefix "$1")/bin/python
}

pyenv_load_installed_python_versions() {
	dpv_check_is_set "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="$(while IFS= read -r line; do
		cut -d/ -f1 <<<"$line" | uniq
	done < <(dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE versions --bare --skip-aliases") | dpv_sort_versions)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS"; then
		return 1
	fi
}

pyenv_load_available_python_versions() {
	dpv_check_is_set "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="$(
		dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE install --list" | grep '^ ' | tr -d ' ' | dpv_sort_versions
		echo
	)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS"; then
		return 1
	fi
}

pyenv_resolve_python_version() {
	while read -r line; do
		local resolved_version=""
		local available_version="none"
		local major_version="$(cut -d. -f1,2 <<<"$line")"

		pyenv_load_installed_python_versions
		while IFS= read -r version; do
			if [[ "$version" == "$line"* ]]; then
				resolved_version=$version
				break
			elif [[ "$version" == "$major_version"* ]]; then
				available_version=$version
			fi
		done <<<"$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS"

		pyenv_load_available_python_versions
		if dpv_check_string_is_empty "$resolved_version"; then
			while IFS= read -r version; do
				if [[ "$version" == "$line"* ]]; then
					resolved_version=$version
					break
				elif [[ "$version" == "$major_version"* ]]; then
					available_version=$version
				fi
			done <<<"$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS"
		fi

		if ! dpv_check_string_is_empty "$resolved_version"; then
			echo $resolved_version
		elif [[ "$available_version" != "none" ]]; then
			echo $available_version
		fi
	done
}

#
# Homebrew utils
#
homebrew_is_available() {
	hash "$CFG_HOMEBREW_EXECUTABLE" 2>/dev/null
}

homebrew_install() {
	while IFS= read -r python_version; do
		if [[ "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" == *"$python_version"* ]]; then
			continue
		fi
		echo "installing python $python_version using homebrew"
		HOMEBREW_NO_AUTO_UPDATE=1 homebrew_exec install $(homebrew_format_python_formula <<<"$python_version") 2>&1 | sed 's/^/  > /'
		echo "ok"
	done
}

homebrew_exec() {
	"$CFG_HOMEBREW_EXECUTABLE" "$@"
}

homebrew_get_python_executable() {
	echo "$(homebrew_exec --prefix $(homebrew_format_python_formula <<<"$1"))"/libexec/bin/python
}

homebrew_load_installed_python_versions() {
	dpv_check_is_set "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" && return

	homebrew_load_available_python_versions

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE list" | grep 'python@' | cut -d@ -f2 | homebrew_expand_python_version | dpv_sort_versions); then
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=""
		return 1
	fi
}

homebrew_load_available_python_versions() {
	dpv_check_is_set "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" && return

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE search python"); then
		result=$(echo "$result" | grep -o 'python@[^ ]\+' | cut -d@ -f2 | homebrew_expand_python_version | dpv_sort_versions)
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=""
		return 1
	fi
}

homebrew_format_python_formula() {
	while read -r line; do
		echo "python@$(cut -d. -f1,2 <<<"$line")"
	done
}

homebrew_resolve_python_version() {
	homebrew_load_available_python_versions

	while read -r line; do
		local available_version="none"
		local major_version="$(cut -d. -f1,2 <<<"$line")"
		if [[ "$line" == "$major_version" ]]; then
			if [[ "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" == *"$major_version"* ]]; then
				homebrew_expand_python_version <<<"$major_version"
				continue
			fi
		else
			local version=$(homebrew_expand_python_version <<<"$major_version")
			if [[ "$version" == "$line" ]]; then
				echo $version
				continue
			fi
		fi
	done
}

homebrew_expand_python_version() {
	while read -r line; do
		major_version="$(cut -d. -f1,2 <<<"$line")"
		formula_path="$(homebrew_exec edit "$(homebrew_format_python_formula <<<"$major_version")" --print-path 2>/dev/null)" || return 1
		while IFS= read -r version; do
			echo $version
			break
		done < <(grep -o "$major_version\.[0-9]\+[a-z]*" "$formula_path")
	done
}

#
# Internals
#

dpv_internal_mktemp_venv_dir() {
	mktemp -d "${TMPDIR:-/tmp/}$(basename "$PWD")-$INTERNAL_VENV_PYTHON_VERSION.tmpXXXXX"
}

dpv_internal_set_log_file() {
	dpv_check_is_set "$INTERNAL_LOG_FILE" && return

	INTERNAL_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
}

unsafe_dpv_internal_set_available_install_methods() {
	#
	# Unsafe:
	# - unsafe_dpv_internal_set_available_install_methods:
	#   - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	dpv_check_is_set "$INTERNAL_AVAILABLE_INSTALL_METHODS" && return

	INTERNAL_AVAILABLE_INSTALL_METHODS="$(while IFS= read -r install; do
		if [[ ${install}_is_available ]]; then
			echo $install
		fi
	done <<<"$CFG_PREFERRED_INSTALL_METHODS")"

	if dpv_check_string_is_empty "$INTERNAL_AVAILABLE_INSTALL_METHODS"; then
		exit "$ERR_NO_AVAILABLE_INSTALL_METHODS"
	fi
}

dpv_internal_run_command_log_failure() {
	tmpfile=$(mktemp)

	# shellcheck disable=SC2068
	bash -c "$@" &>"$tmpfile"
	if [ "$?" -eq 0 ]; then
		cat "$tmpfile"
		return 0
	else
		dpv_internal_log "failed to run command: $*"
		echo -e "$(sed 's/^/  > /' <"$tmpfile")" >>"$INTERNAL_LOG_FILE"
		return 1
	fi
}

dpv_internal_print_logs() {
	if dpv_check_is_set "$INTERNAL_LOG_FILE" && ! dpv_check_file_is_empty "$INTERNAL_LOG_FILE"; then
		printf "\nlogs:\n"
		sed 's/^/  /' <"$INTERNAL_LOG_FILE"
	else
		printf "\nno logs\n"
	fi
}

dpv_internal_log() {
	echo -e "- $@" >>"$INTERNAL_LOG_FILE"
}

#
# General utils
#
dpv_sort_versions() {
	sort --version-sort --reverse
}

dpv_format_nl_to_space() {
	echo -n "$(cat)" | tr '\n' ' '
}

dpv_format_major_version() {
	cut -d. -f1,2
}

dpv_format_highlight_versions() {
	local versions_to_highlight="$1"
	local regex
	regex=$(echo "$versions_to_highlight" | sed -E 's/(\.)/\\\1/g' | tr '\n' '|' | sed 's/|$//')
	sed -E "s/($regex)/\\1*/g"
}

dpv_format_theme() {
	"$CFG_THEME"
}

dpv_filter_mainstream_version() {
	# Ignore versions 2.x, stackless, etc
	grep '^3\.[0-9].\?'
}

dpv_filter_unique_major_versions() {
	local last_major_version
	while IFS= read -r version; do
		local major_version="$(dpv_format_major_version <<<"$version")"
		if [[ "$major_version" != "$last_major_version" ]]; then
			echo $version
			last_major_version=$major_version
		fi
	done
}

dpv_check_file_is_empty() {
	# -s :: Size is > 0 bytes
	! [ -s "$1" ]
}

dpv_check_string_is_empty() {
	# -z :: String is empty
	[[ -z "$1" ]]
}

dpv_check_is_set() {
	# "ø" :: Special value for empty/unset
	[[ "$1" != "ø" ]]
}

# https://stackoverflow.com/a/28776166
(return 0 2>/dev/null) || main "$@"
