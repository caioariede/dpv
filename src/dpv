#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv internal-instrument)"
#
# Usage:
#   Go to the directory of the project and call "dpv"
#
# Code guidelines:
#
# 1. Internal commands should be prefixed with "internal-"
# 2. Commands are displayed in the usage by alphabetical order
# 3. There are four kinds of functions:
#    - command function
#    - command variant functions
#    - initialization functions
#    - short-hand functions
#    - utility functions
# 4. Command functions should be named "cmd_{command name}"
# 5. Command variants functions should be named "cmd_{command name}_{variant}"
# 6. Initialization functions should be named "init_{name}"
# 7. Short-hand functions differently than utilities are not pure
# 8. Utilities are "pure" functions and should be prefixed with "__"
# 9. Exit codes should be stored in constants prefixed with "ERR_"

set -e

ERR_CANNOT_DETERMINE_PYTHON_VERSION=2
ERR_CANNOT_ACTIVATE_VIRTUALENV=3
ERR_NO_INSTALL_METHOD=4
ERR_INVALID_ARGUMENT=5

#
# Command functions
#

cmd_help() {
	init_config_vars

	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv help             - display these instructions"
	echo "  dpv list             - list virtualenvs created with dpv"
	echo "  dpv run [command]    - run command inside virtualenv [default: \$SHELL]"
	echo "    --python [version] - specify python version"
	echo "    --temp             - use a temporary virtualenv"
	echo "  dpv versions         - display installed python versions"
	echo "    --available        - display available ptyhon versions"
	echo "    --all              - display all versions rather than a simplified list"
	echo
	echo "global arguments:"
	echo "  --no-pyenv           - disable pyenv detection"
	echo "  --no-homebrew        - disable homebrew detection"
	echo
	echo "aliases:"
	echo "  dpv / dpv run"
	echo "  dpv [version] / dpv run --python [version]"
	echo "  dpv -h / dpv help"
	echo "  dpv -l / dpv ls / dpv list"
	echo "  dpv -v / dpv versions"
	echo
}

cmd_versions() {
	init_config_vars

	case "$1" in
	"")
		echo "installed python versions"
		echo
		if (_has_pyenv); then
			if result=$(_get_installed_versions_pyenv); then
				echo "pyenv: $(echo "$result" | __pretty_print_delimited_ws)"
			else
				echo "pyenv: failed, check logs"
			fi
		fi
		if (_has_homebrew); then
			if result=$(_get_installed_versions_homebrew); then
				echo "homebrew: $(echo "$result" | __pretty_print_delimited_ws)"
			else
				echo "homebrew: failed, check logs"
			fi
		fi
		;;
	--all)
		echo "all python versions available"
		echo
		if (_has_pyenv); then
			if result=$(_get_all_versions_pyenv); then
				echo "pyenv: $(echo "$result" | __pretty_print_delimited_ws)"
			else
				echo "pyenv: failed, check logs"
			fi
		fi
		if (_has_homebrew); then
			if result=$(_get_available_versions_homebrew); then
				echo "homebrew: $(echo "$result" | __pretty_print_delimited_ws)"
			else
				echo "homebrew: failed, check logs"
			fi
		fi
		;;
	--available)
		echo "available python versions"
		echo
		if (_has_pyenv); then
			if result=$(_get_available_versions_pyenv); then
				echo "pyenv: $(echo "$result" | __pretty_print_delimited_ws)"
			else
				echo "pyenv: failed, check logs"
			fi
		fi
		if (_has_homebrew); then
			if result=$(_get_available_versions_homebrew); then
				echo "homebrew: $(echo "$result" | __pretty_print_delimited_ws)"
			else
				echo "homebrew: failed, check logs"
			fi
		fi
		;;
	*)
		echo "unknown argument: $1"
		;;
	esac
}

cmd_internal_instrument() {
	trap - EXIT

	# https://stackoverflow.com/a/13864829
	if [ -n "${DPV_VENV_DIR+x}" ]; then
		init_config_vars

		echo "source $DPV_VENV_DIR/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
	fi
}

cmd_list() {
	init_config_vars

	find "$CFG_VENVS_DIR" -maxdepth 2 -mindepth 2
}

cmd_run() {
	init_config_vars

	CMD=""

	while [[ "$#" -gt 0 ]]; do
		if [ "$CMD" == "" ]; then
			case "$1" in
			--python)
				shift
				ARG_PYTHON_VERSION="$1"
				shift
				;;
			--temp)
				ARG_TEMP=1
				shift
				;;
			-*)
				echo "invalid argument: $1"
				exit "$ERR_INVALID_ARGUMENT"
				;;
			*)
				CMD=" $1"
				shift
				;;
			esac
		else
			CMD+=" $1"
			shift
		fi
	done

	init_virtualenv_vars

	CMD=${CMD:1}

	if [ -f "$VENV_DIR/dpv.cfg" ]; then
		_log "- found existing virtualenv at $VENV_DIR"
	else
		init_python_vars

		"$PY_EXECUTABLE" -m venv "$VENV_DIR"
		echo -e "path = $PWD\nversion = $VENV_PYTHON_VERSION" >"$VENV_DIR/dpv.cfg"
		_log "- created virtualenv at $VENV_DIR"
	fi

	if [ -n "${DPV_VENV_DIR+x}" ]; then
		trap - EXIT
		exit 0
	fi

	if [ "$CMD" == "" ]; then
		echo "dpv - python $VENV_PYTHON_VERSION activated"
		_print_logs
		DPV_VENV_DIR=$VENV_DIR "$SHELL"
		trap - EXIT
	else
		PATH=$VENV_DIR/bin:$PATH $CMD
	fi
}

#
# Initialization functions
#

init_config_vars() {
	#
	# Initialize CFG_* variables
	#
	CFG_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
	CFG_INSTALL_METHOD="${DPV_INSTALL_METHOD}"
	CFG_AVAILABLE_INSTALL_METHODS=""
	CFG_NO_PYENV=${ARG_NO_PYENV:-0}
	CFG_NO_HOMEBREW=${ARG_NO_HOMEBREW:-0}

	if [ "$CFG_NO_PYENV" == "1" ]; then
		_log "- pyenv disabled"
	elif hash pyenv 2>/dev/null; then
		# https://stackoverflow.com/a/677212
		CFG_AVAILABLE_INSTALL_METHODS+="pyenv;"
		if [ "$CFG_INSTALL_METHOD" == "" ] || [ "$CFG_INSTALL_METHOD" == "pyenv" ]; then
			_log "- pyenv is installed and is the preferred installation method"
			CFG_INSTALL_METHOD="pyenv"
		else
			_log "- pyenv is installed"
		fi
	else
		_log "- pyenv is not installed"
	fi

	if [ "$CFG_NO_HOMEBREW" == "1" ]; then
		_log "- homebrew disabled"
	elif hash brew 2>/dev/null; then
		CFG_AVAILABLE_INSTALL_METHODS+="homebrew;"
		if [ "$CFG_INSTALL_METHOD" == "" ] || [ "$CFG_INSTALL_METHOD" == "homebrew" ]; then
			_log "- homebrew is installed and is the preferred installation method"
			CFG_INSTALL_METHOD="homebrew"
		else
			_log "- homebrew is installed"
		fi
	else
		_log "- homebrew is not installed"
	fi

	if [ "$CFG_INSTALL_METHOD" == "" ]; then
		exit "$ERR_NO_INSTALL_METHOD"
	fi

	CFG_VERSION="1.0.0"
	CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
	CFG_VENVS_DIR="$CFG_DIR/virtualenvs"

	mkdir -p "$CFG_VENVS_DIR"
}

init_virtualenv_vars() {
	#
	# Initialize VENV_ variables
	#
	# Depends on init_config_vars
	#
	VENV_PYTHON_VERSION="$ARG_PYTHON_VERSION"

	# try to locate existing virtualenv
	while IFS= read -r file; do
		local path
		local version
		while IFS= read -r line; do
			if [[ "$line" =~ ^path\ *=\ *(.*) ]]; then
				path="${BASH_REMATCH[1]}"
			elif [[ "$line" =~ ^version\ *=\ *(.*) ]]; then
				version="${BASH_REMATCH[1]}"
			fi
		done <"$file"
		if [[ "$path" == "$PWD" ]]; then
			if [[ "$ARG_PYTHON_VERSION" == "" ]] || [[ "$version" == "$ARG_PYTHON_VERSION"* ]]; then
				newer_version="$(printf "%s\n%s" "$VENV_PYTHON_VERSION" "$version" | sort --version-sort --reverse | head -n 1)"
				if [[ "$version" == "$newer_version" ]]; then
					VENV_PYTHON_VERSION=$version
					if [ "$ARG_TEMP" == "1" ]; then
						VENV_DIR=$(_mktemp_venv_dir)
					else
						VENV_DIR=$(dirname "$file")
					fi
				fi
			fi
		fi
	done < <(find "$CFG_VENVS_DIR" -name dpv.cfg -type f -mindepth 3 -maxdepth 3)

	# try to detect python version from runtime.txt file
	if [ "$VENV_PYTHON_VERSION" == "" ]; then
		_log "- no existing virtualenvs found for $PWD"

		if [ -f "runtime.txt" ]; then
			VENV_PYTHON_VERSION=$(sed 's/^python\-//' <runtime.txt)
			_log "- parsed python version $VENV_PYTHON_VERSION from runtime.txt file"
		else
			_log "- no $PWD/runtime.txt file found"
		fi
	fi

	# normalize python version according to install method
	case "$CFG_INSTALL_METHOD" in
	pyenv)
		VENV_PYTHON_VERSION=$(_to_latest_version_pyenv "$VENV_PYTHON_VERSION")
		;;
	homebrew)
		VENV_PYTHON_VERSION=$(_to_latest_version_homebrew "$(echo "$VENV_PYTHON_VERSION" | __normalize_version_homebrew)")
		;;
	esac

	# otherwise, prompt user about the python version
	if [ "$VENV_PYTHON_VERSION" == "" ]; then
		local default_version=""
		if (_has_pyenv); then
			default_version=$(cut -d: -f2 <(_lazy_get_installed_versions_pyenv))
		elif (_has_homebrew); then
			_cache_installed_versions_homebrew
			default_version=$(cut -d: -f2 <(_lazy_get_installed_versions_homebrew))
		fi
		read -rp "python version [$default_version]: " VENV_PYTHON_VERSION
		VENV_PYTHON_VERSION=${VENV_PYTHON_VERSION:-$default_version}
		_log "- using python version from input: $VENV_PYTHON_VERSION"
	fi

	if [ "$VENV_PYTHON_VERSION" == "" ]; then
		exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
	fi

	if [ "$ARG_TEMP" == "1" ]; then
		VENV_DIR=$(_mktemp_venv_dir)
	else
		VENV_DIR=${VENV_DIR:-$CFG_VENVS_DIR/$VENV_PYTHON_VERSION/$(basename "$PWD")-$VENV_PYTHON_VERSION}
	fi
}

init_python_vars() {
	#
	# Initialize PY_ variables
	#
	# Depends on init_config_vars, init_virtualenv_vars
	#
	local python_version="$VENV_PYTHON_VERSION"

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		if [[ "$(_lazy_get_installed_versions_pyenv)" != *":$python_version:"* ]]; then
			echo "installing python $python_version using pyenv"
			pyenv install "$python_version" 2>&1 | sed 's/^/  > /'
			echo "ok"
		else
			_log "- python $python_version is currently installed by pyenv"
		fi

		PY_PREFIX=$(pyenv prefix "$python_version")
		PY_EXECUTABLE="$PY_PREFIX/bin/python"
		;;
	homebrew)
		python_version=$(echo "$python_version" | __normalize_version_homebrew)
		if [ "$python_version" != "$VENV_PYTHON_VERSION" ]; then
			_log "- homebrew only supports 3.y python versions, using $python_version"
		fi

		if [[ "$_lazy_get_installed_versions_homebrew" != *":$python_version:"* ]]; then
			echo "installing python $python_version using homebrew"
			HOMEBREW_NO_AUTO_UPDATE=1 brew install "python@$python_version" 2>&1 | sed 's/^/  > /'
			echo "ok"
		fi

		PY_PREFIX=$(brew --prefix "python@$python_version")
		PY_EXECUTABLE="$PY_PREFIX/bin/python3"
		;;
	esac
}

#
# Main function
#

main() {
	trap 'error_handling $?' EXIT

	CMD=""
	CMD_ARGS=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		--no-pyenv)
			ARG_NO_PYENV=1
			;;
		--no-homebrew)
			ARG_NO_HOMEBREW=1
			;;
		--*)
			if [ "$CMD" == "" ]; then
				CMD="run"
			fi
			CMD_ARGS+=" $i"
			;;
		*)
			if [ "$CMD" == "" ]; then
				CMD="$i"
			else
				CMD_ARGS+=" $i"
			fi
			;;
		esac
	done

	CMD_ARGS=${CMD_ARGS:1} # drop leading space

	case "$CMD" in
	internal-instrument)
		cmd_internal_instrument
		;;

	list | ls | -l)
		cmd_list
		;;

	2* | 3* | 4*)
		if [[ "$CMD_ARGS" == *"--python"* ]]; then
			trap - EXIT
			echo "dpv cannot run \"dpv [version]\" with \"--python\" - use one or the other"
			exit "$ERR_INVALID_ARGUMENT"
		fi

		# shellcheck disable=2086
		cmd_run --python "$1" $CMD_ARGS
		;;

	run | "")
		# shellcheck disable=2086
		cmd_run $CMD_ARGS
		;;

	versions | -v)
		# shellcheck disable=2086
		cmd_versions $CMD_ARGS
		;;

	help | -h)
		cmd_help
		;;

	*)
		trap - EXIT
		echo "dpv invalid subcommand: $CMD"
		exit "$ERR_INVALID_ARGUMENT"
		;;

	esac
}

#
# Error-handling
#

error_handling() {
	case "$1" in

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		echo "failed to determine python version for $PWD"
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		echo "failed to activate virtualenv $VENV_DIR"
		;;

	"$ERR_NO_INSTALL_METHOD")
		echo "no installation method to pick"
		;;

	esac

	if [ -z "${DPV_INSTRUMENT+x}" ]; then
		_print_logs
	else
		if [ -n "${DPV_VENV_DIR+x}" ]; then
			echo "unset DPV_VENV_DIR"
			echo "exit 1"
		fi
	fi
}

#
# Short-hand functions
#

_log() {
	echo -e "$@" >>"$CFG_LOG_FILE"
}

_print_logs() {
	echo
	echo "logs:"
	sed 's/^/  /' <"$CFG_LOG_FILE"
	echo
}

_run_command_log_failure() {
	tmpfile=$(mktemp)

	# shellcheck disable=SC2068
	if $@ &>"$tmpfile"; then
		cat "$tmpfile"
		exit 0
	else
		_log "- failed to run command: $*"
		_log "$(sed 's/^/  > /' <"$tmpfile")"
		exit 1
	fi
}

_has_pyenv() {
	[[ "$CFG_AVAILABLE_INSTALL_METHODS" =~ "pyenv;" ]] || exit 1
}

_has_homebrew() {
	[[ "$CFG_AVAILABLE_INSTALL_METHODS" =~ "homebrew;" ]] || exit 1
}

_get_installed_versions_pyenv() {
	if result=$(_run_command_log_failure "pyenv versions --bare --skip-aliases"); then
		echo "$result" | cut -d/ -f1 | uniq | sort --version-sort --reverse | __nl_to_delimited
	else
		exit 1
	fi
}

_get_all_versions_pyenv() {
	if result=$(_run_command_log_failure "pyenv install --list"); then
		echo "$result" | sed 's/ //g' | tail -n +2 | __nl_to_delimited
	else
		exit 1
	fi
}

_get_available_versions_pyenv() {
	local supported_python_versions_grep_regex='^\(3\.\([789]\|1[^.]\)\.0$\)\|^\(4\.[0-9]\+\.0$\)'
	if result=$(_run_command_log_failure "pyenv install --list"); then
		echo "$result" | sed 's/ //g' | grep "$supported_python_versions_grep_regex" | __nl_to_delimited
	else
		exit 1
	fi
}

_get_available_versions_homebrew() {
	if result=$(_run_command_log_failure "brew search python"); then
		echo "$result" | grep -o 'python@[^ ]\+' | cut -d@ -f2 | sort --version-sort | __nl_to_delimited
	else
		exit 1
	fi
}

_get_installed_versions_homebrew() {
	if result=$(_run_command_log_failure "brew list"); then
		echo "$result" | grep 'python@' | cut -d@ -f2 | sort --version-sort | __nl_to_delimited
	else
		exit 1
	fi
}

_cache_installed_versions_pyenv() {
	if [ -n "${_CACHED_INSTALLED_VERSIONS_PYENV-x}" ]; then
		_CACHED_INSTALLED_VERSIONS_PYENV=$(_get_installed_versions_pyenv)
	fi
}

_cache_installed_versions_homebrew() {
	if [ -n "${_CACHED_INSTALLED_VERSIONS_HOMEBREW-x}" ]; then
		_CACHED_INSTALLED_VERSIONS_HOMEBREW=$(_get_installed_versions_homebrew)
	fi
}

_lazy_get_installed_versions_pyenv() {
	_cache_installed_versions_pyenv
	echo "$_CACHED_INSTALLED_VERSIONS_PYENV"
}

_lazy_get_installed_versions_homebrew() {
	_cache_installed_versions_homebrew
	echo "$_CACHED_INSTALLED_VERSIONS_HOMEBREW"
}

_mktemp_venv_dir() {
	mktemp -d "${TMPDIR:-/tmp/}$(basename "$PWD")-$VENV_PYTHON_VERSION.tmpXXXXX"
}

_to_latest_version_pyenv() {
	if [[ "$1" =~ ^[0-9]*\.[0-9]*\.[0-9]*$ ]]; then
		echo "$1"
	else
		for line in $(_lazy_get_installed_versions_pyenv | sed -E 's/:/\n/g'); do
			if [[ "$line" == "$1"* ]]; then
				echo "$line"
				break
			fi
		done
	fi
}

_to_latest_version_homebrew() {
	if [[ "$1" =~ ^[0-9]*\.[0-9]*$ ]]; then
		"$(brew --prefix "python@$1")"/bin/python3 --version | cut -d\  -f2
	else
		for line in $(_lazy_get_installed_versions_homebrew | sed -E 's/:/\n/g'); do
			if [[ "$line" == "$1"* ]]; then
				"$(brew --prefix "python@$line")"/bin/python3 --version | cut -d\  -f2
				break
			fi
		done
	fi
}

#
# Utilities
#

__pretty_print_delimited_ws() {
	# Transforms multiple lines in one separated by spaces
	sed -E 's/^:|:$//g' | tr ':' ' '
}

__nl_to_delimited() {
	# a\nb\n\nc\n\n => :a:b:c:
	tr '\n' ':' | sed -E 's/^|$|:+/:/g'
}

__normalize_version_homebrew() {
	# 3.7.12 => 3.7
	sed 's/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)$/\1.\2/'
}

main "$@"
