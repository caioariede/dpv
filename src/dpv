#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv internal-instrument)"
#
# Usage:
#   Go to the directory of the project and call "dpv"
#
# Code guidelines:
#
# 1. Internal commands should be prefixed with "internal-"
# 2. Commands are displayed in the usage by alphabetical order
# 3. There are four kinds of functions:
#    - command function
#    - command variant functions
#    - initialization functions
#    - short-hand functions
#    - utility functions
# 4. Command functions should be named "cmd_{command name}"
# 5. Command variants functions should be named "cmd_{command name}_{variant}"
# 6. Initialization functions should be named "init_{name}"
# 7. Short-hand functions differently than utilities are not pure
# 8. Utilities are "pure" functions and should be prefixed with "_util_"
# 9. Exit codes should be stored in constants prefixed with "ERR_"

set -e

ERR_CANNOT_DETERMINE_PYTHON_VERSION=2
ERR_CANNOT_ACTIVATE_VIRTUALENV=3
ERR_NO_INSTALL_METHOD=4

#
# Command functions
#

cmd_help() {
	init_config_vars

	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv             - installs virtualenv for the current directory"
	echo "  dpv help        - display these instructions"
	echo "  dpv list        - lists virtualenvs managed by dpv"
	echo "  dpv run [cmd]   - runs command inside virtualenv [default: \$SHELL]"
	echo "  dpv versions    - display python versions"
	echo "    --all         - include all versions rather than a simplified list"
	echo "    --installed   - only display versions that are currently installed"
	echo "  dpv where       - display the virtualenv directory"
	echo
	echo "global arguments:"
	echo "  -q / --quiet    - do not show logs"
	echo
	echo "aliases:"
	echo "  dpv -h / dpv help"
	echo "  dpv -l / dpv ls / dpv list"
	echo "  dpv -v / dpv versions"
	echo
}

cmd_versions() {
	init_config_vars

	case "$1" in
	--installed)
		echo "retrieving installed python versions..."
		echo
		_has_pyenv && (
			echo -n "pyenv: "
			_cmd_versions_installed_pyenv
		)
		_has_homebrew && (
			echo -n "homebrew: "
			_cmd_versions_installed_homebrew
		)
		;;
	--all)
		echo "retrieving all available python versions..."
		echo
		_has_pyenv && (
			echo -n "pyenv: "
			_cmd_versions_all_pyenv
		)
		_has_homebrew && (
			echo -n "homebrew: "
			_cmd_versions_available_homebrew
		)
		;;
	*)
		echo "retrieving available python versions..."
		echo
		_has_pyenv && (
			echo -n "pyenv: "
			_cmd_versions_available_pyenv
		)
		_has_homebrew && (
			echo -n "homebrew: "
			_cmd_versions_available_homebrew
		)
		;;
	esac
}

_cmd_versions_installed_pyenv() {
	if result=$(_run_command_log_failure "pyenv versions --bare --skip-aliases"); then
		echo "$result" | cut -d/ -f1 | uniq | sort --version-sort | tr '\n' ' '
		echo
	else
		echo "failed, check logs"
	fi
}

_cmd_versions_all_pyenv() {
	if result=$(_run_command_log_failure "pyenv install --list"); then
		echo "$result" | sed 's/ //g' | tail -n +2 | tr '\n' ' '
		echo
	else
		echo "failed, check logs"
	fi
}

_cmd_versions_available_pyenv() {
	local supported_python_versions_grep_regex='^\(3\.\([789]\|1[^.]\)\.0$\)\|^\(4\.[0-9]\+\.0$\)'
	if result=$(_run_command_log_failure "pyenv install --list"); then
		echo "$result" | sed 's/ //g' | grep "$supported_python_versions_grep_regex" | _util_strip_point_zero | tr '\n' ' '
		echo
	else
		echo "failed, check logs"
	fi
}

_cmd_versions_available_homebrew() {
	if result=$(_run_command_log_failure "brew search python"); then
		echo "$result" | grep -o 'python@[^ ]\+' | cut -d@ -f2 | sort --version-sort | tr '\n' ' '
		echo
	fi
}

_cmd_versions_installed_homebrew() {
	if result=$(_run_command_log_failure "brew list"); then
		echo "$result" | grep 'python@' | cut -d@ -f2 | sort --version-sort | tr '\n' ' '
		echo
	fi
}

cmd_where() {
	init_config_vars
	init_virtualenv_vars

	echo "$VENV_DIR"
}

cmd_internal_instrument() {
	trap - EXIT

	# https://stackoverflow.com/a/13864829
	if [ -n "${DPV_SHELL+x}" ]; then
		init_config_vars
		init_virtualenv_vars

		echo "source $VENV_DIR/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
	fi
}

cmd_list() {
	init_config_vars

	find "$CFG_VENVS_DIR" -maxdepth 2 -mindepth 2
}

cmd_run() {
	init_config_vars
	init_virtualenv_vars

	if [ ! -d "$VENV_DIR" ]; then
		"$PY_EXECUTABLE" -m venv "$VENV_DIR"
	fi

	if [ -n "${DPV_SHELL+x}" ]; then
		trap - EXIT
		exit 0
	fi

	if [ "$#" -eq 0 ]; then
		_print_logs
		DPV_SHELL=1 "$SHELL"
		trap - EXIT
	else
		PATH=$VENV_DIR/bin:$PATH "$@"
	fi
}

#
# Initialization functions
#

init_config_vars() {
	CFG_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
	CFG_INSTALL_METHOD="${DPV_INSTALL_METHOD}"
	CFG_AVAILABLE_INSTALL_METHODS=""
	CFG_QUIET="${ARG_QUIET:-${DPV_QUIET:-0}}"

	# https://stackoverflow.com/a/677212
	if hash pyenv 2>/dev/null; then
		CFG_AVAILABLE_INSTALL_METHODS+="pyenv;"
		if [ "$CFG_INSTALL_METHOD" == "" ] || [ "$CFG_INSTALL_METHOD" == "pyenv" ]; then
			_log "- pyenv is installed and is the preferred installation method"
			CFG_INSTALL_METHOD="pyenv"
		else
			_log "- pyenv is installed"
		fi
	else
		_log "- pyenv is not installed"
	fi
	if hash brew 2>/dev/null; then
		CFG_AVAILABLE_INSTALL_METHODS+="homebrew;"
		if [ "$CFG_INSTALL_METHOD" == "" ] || [ "$CFG_INSTALL_METHOD" == "homebrew" ]; then
			_log "- homebrew is installed and is the preferred installation method"
			CFG_INSTALL_METHOD="homebrew"
		else
			_log "- homebrew is installed"
		fi
	else
		_log "- homebrew is not installed"
	fi

	if [ "$CFG_INSTALL_METHOD" == "" ]; then
		exit "$ERR_NO_INSTALL_METHOD"
	fi

	CFG_VERSION="1.0.0"
	CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
	CFG_VENVS_DIR="$CFG_DIR/virtualenvs"

	mkdir -p "$CFG_VENVS_DIR"
}

init_virtualenv_vars() {
	if [ -f "runtime.txt" ]; then
		PY_VERSION=$(sed 's/^python\-//' <runtime.txt)
		_log "- parsed python version $PY_VERSION from runtime.txt file"
	else
		_log "- cannot find $PWD/runtime.txt file"
		exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
	fi

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		_log "- checking installation of $PY_VERSION with pyenv"
		_log "$(sed s'/^/  > /' <(pyenv install "$PY_VERSION" --skip-existing 2>&1))"
		_log "  ok"

		PY_PREFIX=$(pyenv prefix "$PY_VERSION")
		PY_EXECUTABLE="$PY_PREFIX/bin/python"
		;;
	homebrew)
		if [ "$(_util_count_char "$PY_VERSION" '.')" -gt 1 ]; then
			python_version=$(cut -d. -f1,2 <(echo "$PY_VERSION"))
			_log "- homebrew only supports 3.y python versions, using $PY_VERSION"
		fi

		_log "- checking installation of $PY_VERSION with homebrew"
		_log "$(sed 's/^/  > /' <(HOMEBREW_NO_AUTO_UPDATE=1 brew install "python@$PY_VERSION" 2>&1))"
		_log "  ok"

		PY_PREFIX=$(brew --prefix "python@$PY_VERSION")
		PY_EXECUTABLE="$PY_PREFIX/bin/python3"
		;;
	esac

	VENV_DIR=$CFG_VENVS_DIR/$PY_VERSION/$(basename "$PWD")-$PY_VERSION
}

#
# Main function
#

main() {
	trap 'error_handling $?' EXIT

	CMD=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		-q | --quiet)
			ARG_QUIET=1
			shift
			;;
		*)
			if [ "$CMD" == "" ]; then
				CMD="$i"
				shift
			else
				break
			fi
			;;
		esac
	done

	case "$CMD" in
	where)
		cmd_where
		;;

	internal-instrument)
		cmd_internal_instrument
		;;

	list | ls | -l)
		cmd_list
		;;

	run | "")
		cmd_run "$@"
		;;

	versions | -v)
		cmd_versions "${@:1}"
		;;

	help | -h)
		cmd_help
		;;

	*)
		trap - EXIT
		echo "dpv invalid subcommand: $CMD"
		exit 1
		;;

	esac
}

#
# Error-handling
#

error_handling() {
	case "$1" in

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		echo "failed to determine python version for $PWD"
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		echo "failed to activate virtualenv $VENV_DIR"
		;;

	"$ERR_NO_INSTALL_METHOD")
		echo "no installation methods found"
		;;

	esac

	if [ -z "${DPV_INSTRUMENT+x}" ]; then
		_print_logs
	else
		if [ -n "${DPV_SHELL+x}" ]; then
			echo "unset DPV_SHELL"
			echo "exit 1"
		fi
	fi
}

#
# Short-hand functions
#

_log() {
	echo -e "$@" >>"$CFG_LOG_FILE"
}

_print_logs() {
	if [[ "$CFG_QUIET" -eq 0 ]]; then
		echo
		echo "logs:"
		sed 's/^/  /' <"$CFG_LOG_FILE"
		echo
	fi
}

_run_command_log_failure() {
	tmpfile=$(mktemp)

	# shellcheck disable=SC2068
	if $@ &>"$tmpfile"; then
		cat "$tmpfile"
		exit 0
	else
		_log "- failed to run command: $*"
		_log "$(sed 's/^/  > /' <"$tmpfile")"
		exit 1
	fi
}

_has_pyenv() {
	[[ "$CFG_AVAILABLE_INSTALL_METHODS" =~ "pyenv;" ]] || exit 1
}

_has_homebrew() {
	[[ "$CFG_AVAILABLE_INSTALL_METHODS" =~ "homebrew;" ]] || exit 1
}

#
# Utilities
#

_util_count_char() {
	echo "$1" | tr -cd "$2" | wc -c
}

_util_strip_point_zero() {
	sed 's/\.0$//'
}

main "$@"
