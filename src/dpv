#!/bin/sh
#
# the d̲ead simple P̲ython v̲irtualenv manager
#
#
# LICENCE
# =====================================================================================
#
# MIT License
#
# Copyright (c) 2023 Caio Ariede
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
# INSTALLATION
# =====================================================================================
#
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv internal-load-shell)"
#
#
# USAGE
# =====================================================================================
#
#   Type: dpv help
#
#
# CODE GUIDELINES
# =====================================================================================
#
# 1. Functions must be prefixed with "dpv_"
# 2. Unsafe functions (one that may exit) must be prefixed with "unsafe_dpv_"
# 3. Stateful functions (depending on INTERNAL_ vars) must be prefixed with "dpv_internal_"
# 4. Functions that perform operations over pipes must be prefixed with "dpv_pipe_"
# 5. Functions that returns boolean must be prefixed with "dpv_check_"
# 6. The ø character is used to define emptiness (empty value)
# 7. Exit codes are stored in variables prefixed with "ERR_"
# 8. Configuration values are stored in variables prefixed with "CFG_"
# 9. Vendor functions are prefixed with "dpv_VENDOR_" (vendor must be in uppercase)
#

set -eu

#
# Error exit codes
#

ERR_MAIN_INVALID_ARGUMENT=131
ERR_INSTALL_METHOD_NOT_SELECTED=132
ERR_CANNOT_ACTIVATE_VIRTUALENV=133
ERR_RUN_INVALID_ARGUMENT=134
ERR_CANNOT_DETERMINE_PYTHON_VERSION=135
ERR_NO_AVAILABLE_INSTALL_METHODS=136
ERR_CANNOT_RESOLVE_PYTHON_VERSION=137
ERR_VIRTUALENV_INSTALL_METHOD_NOT_AVAILABLE=138
ERR_INSTALLATION_FAILED=139
ERR_CANNOT_CREATE_VIRTUALENV=140
ERR_CANNOT_INSTALL_DEPENDENCIES=142
ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE=141
ERR_TRY_MISSING_DEPENDENCY_ARG=143

# VARS: Configuration
CFG_VERSION="0.12.0"
CFG_THEME="${DPV_THEME:-cat}"
CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
CFG_VIRTUALENVS_DIR="${DPV_MOCK_VIRTUALENVS_DIR:-$CFG_DIR/virtualenvs}"
CFG_HOMEBREW_EXECUTABLE="${HOMEBREW_EXECUTABLE:-brew}"
CFG_PYENV_EXECUTABLE="${PYENV_EXECUTABLE:-pyenv}"
CFG_UV_EXECUTABLE="${UV_EXECUTABLE:-uv}"
CFG_PREFERRED_INSTALL_METHODS="UV PYENV HOMEBREW"

# VARS: Internal
INTERNAL_UV_PROJECT_DIR="${DPV_MOCK_UV_PROJECT_DIR:-ø}"
INTERNAL_UV_INSTALLED_PYTHON_VERSIONS="$([ ! -z "${DPV_MOCK_UV_INSTALLED_PYTHON_VERSIONS+x}" ] && echo "$DPV_MOCK_UV_INSTALLED_PYTHON_VERSIONS" || echo "ø")"
INTERNAL_UV_AVAILABLE_PYTHON_VERSIONS="${DPV_MOCK_UV_AVAILABLE_PYTHON_VERSIONS:-ø}"
INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="$([ ! -z "${DPV_MOCK_PYENV_INSTALLED_PYTHON_VERSIONS+x}" ] && echo "$DPV_MOCK_PYENV_INSTALLED_PYTHON_VERSIONS" || echo "ø")"
INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="${DPV_MOCK_PYENV_AVAILABLE_PYTHON_VERSIONS:-ø}"
INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS="$([ ! -z "${DPV_MOCK_HOMEBREW_INSTALLED_PYTHON_VERSIONS+x}" ] && echo "$DPV_MOCK_HOMEBREW_INSTALLED_PYTHON_VERSIONS" || echo "ø")"
INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS="${DPV_MOCK_HOMEBREW_AVAILABLE_PYTHON_VERSIONS:-ø}"
INTERNAL_AVAILABLE_INSTALL_METHODS="${DPV_MOCK_AVAILABLE_INSTALL_METHODS:-ø}"
INTERNAL_LOG_FILE="${DPV_MOCK_LOG_FILE:-ø}"
INTERNAL_RESOLVE_PYTHON_VERSION="${DPV_MOCK_RESOLVE_PYTHON_VERSION:-ø}"
INTERNAL_RESOLVE_INSTALL_METHOD="${DPV_MOCK_RESOLVE_INSTALL_METHOD:-ø}"
INTERNAL_ARG_PYTHON_VERSION="${DPV_MOCK_ARG_PYTHON_VERSION:-ø}"
INTERNAL_ARG_DEPS="${DPV_MOCK_ARG_DEPS:-ø}"
INTERNAL_INITIALIZE_VIRTUALENV_install_method="${DPV_MOCK_VIRTUALENV_INSTALL_METHOD:-ø}"
INTERNAL_INITIALIZE_VIRTUALENV_python_version="${DPV_MOCK_VIRTUALENV_PYTHON_VERSION:-ø}"
INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir="${DPV_MOCK_VIRTUALENV_DIR:-${DPV_VIRTUALENV_DIR:-ø}}"

DPV_MOCK_PIP="${DPV_MOCK_PIP:-ø}"
DPV_MOCK_UV_INSTALL="${DPV_MOCK_UV_INSTALL:-ø}"

#
# Command functions
#
# These functions are called by the dpv_internal_main() function
# Unsafe commands should set a trap to the dpv_internal_error_handling() function
#

dpv_cmd_help() {
	#
	# Command: dpv help / dpv --help / dpv -h
	# Displays available commands and options
	#
	echo "dpv $CFG_VERSION"
	echo
	echo "usage:"
	echo "  dpv [python version]"
	echo
	echo "commands:"
	echo "  dpv help               - display these instructions"
	echo "  dpv info               - display information about the current virtualenv"
	echo "  dpv list               - list virtualenvs created with dpv"
	echo "  dpv run [command]      - run command inside virtualenv [default: \$SHELL]"
	echo "    --python [version]   - specify python version"
	echo "    --temp/--tmp         - use a temporary virtualenv"
	echo "    --with/-w [dep]      - specify dependencies to pre-install"
	echo "  dpv try [dep]          - install dependency and start python shell"
	echo "  dpv try [dep] -- [cmd] - install dependency and run command"
	echo "    --with/-w [dep]      - install extra dependency before running command"
	echo "  dpv versions           - display available python versions"
	echo "    --installed/-i       - display installed python versions"
	echo "    --all/-a             - display extended list of available python versions"
	echo "  dpv drop [name]        - remove virtualenv"
	echo "    --dry-run/-d         - show directories that would be removed"
	echo
	echo "global arguments:"
	echo "  --uv                   - use uv"
	echo "  --pyenv                - use pyenv"
	echo "  --homebrew             - use homebrew"
	echo
	echo "aliases:"
	echo "  dpv run / dpv"
	echo "  dpv [version] / dpv run --python [version]"
	echo "  dpv info / dpv (when virtualenv is activated)"
	echo "  dpv help / --help / -h"
	echo "  dpv list / --list / ls / -l"
	echo "  dpv versions / -v"
	echo "  dpv versions --all / -a"
	echo

	dpv_print_config
}

dpv_internal_cmd_versions() {
	#
	# Command: dpv versions
	# Lists the available Python versions
	#
	unsafe_dpv_internal_set_available_install_methods

	case "${1:-}" in
	--installed | -i)
		#
		# Command: dpv versions --installed
		# Lists *only* installed versions
		#
		echo "command: installed python versions"
		echo

		while IFS= read -r install; do
			eval "dpv_internal_${install}_installed_python_versions"

			installed_versions_var="INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS"
			installed_versions=$(eval "echo \"\$$installed_versions_var\"")

			echo "$(dpv_string_lowercase "$install"): $(echo "$installed_versions" | dpv_internal_pipe_format_python_versions "$install" --all | dpv_pipe_format_nl_to_space)"
		done <<EOF
$INTERNAL_AVAILABLE_INSTALL_METHODS
EOF
		;;

	--all | -a)
		#
		# Command: dpv versions --all / dpv versions -a
		# Lists *all* versions
		#
		echo "command: available python versions (extended list)"
		echo

		while IFS= read -r install; do
			eval "dpv_internal_${install}_available_python_versions"
			eval "dpv_internal_${install}_installed_python_versions"

			available_versions_var="INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS"
			available_versions=$(eval "echo \"\$$available_versions_var\"")

			echo "$(dpv_string_lowercase "$install"): $(echo "$available_versions" | dpv_internal_pipe_format_python_versions "$install" --all | dpv_pipe_format_nl_to_space)"
		done <<EOF
$INTERNAL_AVAILABLE_INSTALL_METHODS
EOF
		;;

	"")
		#
		# Command: dpv versions
		# List *all* versions excluding those that are not considered mainstream (eg. pypy)
		#
		echo "command: available python versions"
		echo

		while IFS= read -r install; do
			eval "dpv_internal_${install}_available_python_versions"
			eval "dpv_internal_${install}_installed_python_versions"

			available_versions_var="INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS"
			available_versions=$(eval "echo \"\$$available_versions_var\"")

			echo "$(dpv_string_lowercase "$install"): $(echo "$available_versions" | dpv_internal_pipe_format_python_versions "$install" | dpv_pipe_format_nl_to_space)"
		done <<EOF
$INTERNAL_AVAILABLE_INSTALL_METHODS
EOF
		;;

	*)
		echo "error: unknown argument $1"
		;;

	esac
}

dpv_internal_cmd_drop() {
	#
	# Command: dpv drop [name]
	# Removed a virtualenv
	#
	echo "command: drop virtualenv"
	echo

	opt_name=""
	opt_dry_run=0

	while [ $# -gt 0 ]; do
		case "$1" in
		--dry-run | -d)
			opt_dry_run=1
			;;
		*)
			if dpv_check_string_is_empty "$opt_name"; then
				opt_name="$1"
			else
				echo "error: drop command does not accept multiple virtualenvs"
				exit 1
			fi
			;;
		esac
		shift
	done

	if dpv_check_string_is_empty "$opt_name"; then
		#
		# Command: dpv drop
		# Removes the current virtualenv
		#
		if dpv_check_is_set "$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir"; then
			remove_dir="$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir"
			if [ "$(dpv_string_count_characters "$remove_dir" "/")" -lt 2 ]; then
				echo "aborting! it doesn't seem the right directory to delete: $remove_dir"
			elif [ "$opt_dry_run" -eq 1 ]; then
				echo "would drop $remove_dir"
			else
				rm -rf "$remove_dir"
				echo "dropped $remove_dir"
				kill -s USR1 "$PPID"
			fi
		else
			echo "error: virtualenv not activated"
			exit 1
		fi
	else
		#
		# Command: dpv drop [name]
		# Removes the virtualenv matching [name]
		#
		find "$CFG_VIRTUALENVS_DIR" -maxdepth 2 -mindepth 2 -iname "$opt_name" | while IFS= read -r line; do
			if [ "$opt_dry_run" -eq 1 ]; then
				echo "would drop $line"
			else
				rm -rf "$line"
				echo "dropped $line"
			fi
		done
	fi
}

unsafe_dpv_cmd_internal_load_shell() {
	#
	# Command: dpv internal-load-shell
	# Instruments dpv in the current shell
	#
	# Unsafe:
	# - ERR_CANNOT_ACTIVATE_VIRTUALENV
	#
	dpv_check_is_set "$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir" || return

	echo "trap 'echo \"deactivated\" >&2; exit' SIGUSR1"
	echo "source $INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
}

dpv_cmd_list() {
	#
	# Command: dpv list
	# Lists virtualenvs managed by dpv
	#
	echo "command: list of virtualenvs"
	echo

	mkdir -p "$CFG_VIRTUALENVS_DIR"
	sort_key="$(($(dpv_string_count_characters "$CFG_VIRTUALENVS_DIR" "/") + 3))"

	find "$CFG_VIRTUALENVS_DIR" -maxdepth 2 -mindepth 2 | dpv_pipe_sort_path "$sort_key"
}

unsafe_dpv_internal_cmd_info() {
	#
	# Command: dpv info
	# Provides multiple information:
	# - Current virtualenv: if there is a virtualenv associated with the current
	#   directory, displays information about it
	# - Config: display config information
	# - Logs: if any logs are available, print them
	#
	# Unsafe:
	# - unsafe_dpv_internal_set_available_install_methods
	#
	#
	echo "command: info"
	echo

	# Check available installation methods
	# If not possible, this will error out with: ERR_NO_AVAILABLE_INSTALL_METHODS
	unsafe_dpv_internal_set_available_install_methods

	dpv_internal_scan_python_version 1>/dev/null || true

	# Current virtualenv information
	virtualenvs_output="$(dpv_internal_find_virtualenvs)"
	if ! dpv_check_string_is_empty "$virtualenvs_output"; then
		while IFS= read -r virtualenv_dir; do
			dpv_internal_print_virtualenv "$virtualenv_dir"
			printf "\n"
		done <<EOF
$virtualenvs_output
EOF
	fi

	# Config information
	dpv_print_config

	# Logs
	dpv_internal_print_logs
}

unsafe_dpv_internal_cmd_run_wrapper() {
	#
	# Command: dpv run [command]
	# Executes a command inside a virtualenv
	#
	# Note: this is a wrapper around the function below (unsafe_dpv_internal_cmd_run)
	#
	# Variations:
	# - Command is provided: executes command inside a virtualenv for the current
	#   directory. If no virtualenv exists, creates a new one.
	# - Command is not provided:
	#   - Virtualenv is not activated: starts a shell in the virtualenv related to the
	#     current directory. If no virtualenv exists, creates a new one.
	#   - Virtualenv is activated: prints information (same as: dpv info)
	#
	# Unsafe:
	# - unsafe_dpv_internal_cmd_info
	# - unsafe_dpv_internal_cmd_run
	#
	if dpv_check_is_set "$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir"; then
		# Print information
		unsafe_dpv_internal_cmd_info | dpv_pipe_format_theme
	else
		# Execute command
		# shellcheck disable=2068
		unsafe_dpv_internal_cmd_run $@
	fi
}

unsafe_dpv_internal_cmd_run() {
	#
	# Command: dpv run [command]
	# Executes a command inside a virtualenv
	#
	# Unsafe:
	# - ERR_RUN_INVALID_ARGUMENT
	# - unsafe_dpv_internal_initialize_virtualenv
	#
	CMD=""

	while [ "$#" -gt 0 ]; do
		if [ "$CMD" = "" ]; then
			case "$1" in
			--python)
				#
				# Command: dpv run --python [version]
				# Executes command using a virtualenv with the specified Python version
				#
				shift
				INTERNAL_ARG_PYTHON_VERSION="$1"
				shift
				;;
			--tmp | --temp)
				#
				# Command: dpv run --tmp
				# Executes command inside a temporary virtualenv
				#
				ARG_TEMP=1
				shift
				;;
			--with | -w)
				#
				# Command: dpv run --with [dep]
				# Specify packages to be installed before running command
				#
				shift
				if dpv_check_is_set "$INTERNAL_ARG_DEPS"; then
					INTERNAL_ARG_DEPS="$INTERNAL_ARG_DEPS $1"
				else
					INTERNAL_ARG_DEPS="$1"
				fi
				shift
				;;
			--)
				CMD=" "
				shift
				;;
			-*)
				echo "error: invalid argument: $1"
				exit "$ERR_RUN_INVALID_ARGUMENT"
				;;
			*)
				CMD=" $1"
				shift
				;;
			esac
		else
			CMD="$CMD $1"
			shift
		fi
	done

	CMD=$(
		cut -c2- <<EOF
$CMD
EOF
	)

	# Load information about virtualenv for the current directory
	unsafe_dpv_internal_initialize_virtualenv

	trap - EXIT
	if [ "$CMD" = "" ]; then
		#
		# Command: dpv run
		# No command provided: starts virtualenv
		#
		DPV_VIRTUALENV_DIR=$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir dpv_internal_print_shell_banner | dpv_pipe_format_theme
		DPV_VIRTUALENV_DIR=$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir "$SHELL"
	else
		#
		# Command: dpv run [command]
		# Executes command inside virtualenv
		#
		PATH=$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir/bin:$PATH $CMD
	fi
}

unsafe_dpv_cmd_try() {
	case "$1" in
	-* | "")
		exit "$ERR_TRY_MISSING_DEPENDENCY_ARG"
		;;
	*)
		dep="$1"
		shift
		args=""
		cmd_set=0
		py_packages="$dep"
		while [ "$#" -gt 0 ]; do
			case "$1" in
			--)
				cmd_set=1
				;;
			--with | -w)
				args="$args $1"
				shift
				py_packages="$py_packages,$1"
				;;
			esac
			args="$args $1"
			shift
		done
		if [ "$cmd_set" -eq 0 ]; then
			args="$args -- python"
		fi
		dpv_python_startup="$(dpv_make_temp_file)"
		cat <<EOF >"$dpv_python_startup"

def dpv_get_modules(packages):
    try:
        from importlib.metadata import packages_distributions
    except ImportError:
        import logging
        logging.warning("dpv only auto-import modules with Python 3.10+")
    else:
        import pkg_resources

        packages = [r.name for r in pkg_resources.parse_requirements(packages)]
        print(f"loading packages: {', '.join(packages)}")
        print("")
        for m, names in packages_distributions().items():
            for n in names:
                if n in packages:
                    yield m

print("")
print("welcome to dpv try shell! :)")
print("")

for m in dpv_get_modules("$py_packages".split(",")):
    locals()[m] = __import__(m)
    print(f"- dpv imported module: {m}")

print("")

EOF
		PYTHONSTARTUP="$dpv_python_startup" unsafe_dpv_internal_cmd_run_wrapper "--with $dep --temp $args"
		;;
	esac
}

#
# Internal functions
#
dpv_internal_print_shell_banner() {
	#
	# Prints the banner when starting a virtualenv
	#
	printf "command: shell\n\n"

	dpv_internal_print_virtualenv "$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir"
	dpv_internal_print_logs
}

dpv_print_config() {
	#
	# Prints current configuration
	#
	printf "config:\n"
	printf "  CFG_VIRTUALENVS_DIR=%s\n" "$CFG_VIRTUALENVS_DIR"
	printf "  CFG_THEME=%s\n" "$CFG_THEME"
	printf "  CFG_DIR=%s\n" "$CFG_DIR"
	printf "  CFG_UV_EXECUTABLE=%s\n" "$CFG_UV_EXECUTABLE"
	printf "  CFG_PYENV_EXECUTABLE=%s\n" "$CFG_PYENV_EXECUTABLE"
	printf "  CFG_HOMEBREW_EXECUTABLE=%s\n" "$CFG_HOMEBREW_EXECUTABLE"
	printf "  CFG_PREFERRED_INSTALL_METHODS=%s\n" "$CFG_PREFERRED_INSTALL_METHODS"
}

dpv_internal_print_virtualenv() {
	#
	# Prints information for the given virtualenv
	#
	virtualenv_dir="$1"

	dpv_internal_parse_virtualenv_config_file "$virtualenv_dir/dpv.cfg"

	printf "virtualenv:\n"
	printf "  name: %s\n" "$(basename "$virtualenv_dir")"
	printf "  virtualenv path: %s\n" "$virtualenv_dir"
	printf "  project path: %s\n" "$INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_path"
	printf "  python version: %s\n" "$INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_install_method"
	printf "  installation method: %s\n" "$INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_install_method"
	if [ "$INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir" = "$virtualenv_dir" ]; then
		printf "  status: activated\n"
	else
		printf "  status: not activated\n"
	fi
}

dpv_internal_print_logs() {
	#
	# Prints logs (if any)
	#
	if dpv_check_is_set "$INTERNAL_LOG_FILE" && ! dpv_check_file_is_empty "$INTERNAL_LOG_FILE"; then
		printf "\nlogs:\n"
		dpv_pipe_quote "-" <"$INTERNAL_LOG_FILE"
	fi
}

unsafe_dpv_internal_initialize_virtualenv() {
	#
	# Tries to find an existing virtualenv matching the following:
	# 1. The directory path
	# 2. The Python version, if provided as an argument
	#
	# If not match, a Python version is asked to the user
	# Once a Python version is provided, look for the closest match:
	# 1. Already installed by one of the installation methods
	# 2. Available by one of the installation methods
	# 3. Error out (ERR_CANNOT_RESOLVE_PYTHON_VERSION)
	#
	# Loads:
	# - INTERNAL_INITIALIZE_VIRTUALENV_python_version: The version resolved for the virtualenv
	# - INTERNAL_INITIALIZE_VIRTUALENV_install_method: The installaton method resolved for the virtualenv
	# - INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir: The directory path for the virtualenv
	#
	# Unsafe:
	# - unsafe_dpv_internal_initialize_virtualenv
	# - unsafe_dpv_internal_set_available_install_methods
	# - unsafe_dpv_internal_install_deps
	#
	if dpv_internal_scan_virtualenv; then
		# An existing virtualenv has been found, just use it
		INTERNAL_INITIALIZE_VIRTUALENV_python_version=$INTERNAL_SCAN_VIRTUALENV_version
		INTERNAL_INITIALIZE_VIRTUALENV_install_method=$INTERNAL_SCAN_VIRTUALENV_install_method
		INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir=$INTERNAL_SCAN_VIRTUALENV_virtualenv_dir
		return
	fi

	# Check available installation methods
	# If not possible, this will error out with: ERR_NO_AVAILABLE_INSTALL_METHODS
	unsafe_dpv_internal_set_available_install_methods

	# Try to determine the Python version to use
	# If not possible, this will error out
	if ! dpv_internal_scan_python_version; then
		exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
	fi

	# Prompt user to confirm this is the Python version wanted
	python_version_user_input=""
	printf "python version [default: %s source: %s]: " "$INTERNAL_SCAN_PYTHON_VERSION_version" "$INTERNAL_SCAN_PYTHON_VERSION_source"
	read -r python_version_user_input
	INTERNAL_INITIALIZE_VIRTUALENV_python_version="${python_version_user_input:-$INTERNAL_SCAN_PYTHON_VERSION_version}"

	# Resolve Python version
	# If not possible, this will error out with: ERR_CANNOT_RESOLVE_PYTHON_VERSION
	if dpv_internal_resolve_python_version "$INTERNAL_INITIALIZE_VIRTUALENV_python_version"; then
		INTERNAL_INITIALIZE_VIRTUALENV_install_method="$INTERNAL_RESOLVE_INSTALL_METHOD"
		INTERNAL_INITIALIZE_VIRTUALENV_python_version="$INTERNAL_RESOLVE_PYTHON_VERSION"
	else
		exit "$ERR_CANNOT_RESOLVE_PYTHON_VERSION"
	fi

	# Install Python version
	# If version is already installed, install will be skipped
	# If not possible, this will error out with: ERR_INSTALLATION_FAILED
	func=$(eval "echo \"unsafe_dpv_internal_\"$INTERNAL_INITIALIZE_VIRTUALENV_install_method\"_install\"")
	eval "$func" <<EOF
$INTERNAL_INITIALIZE_VIRTUALENV_python_version
EOF

	# Create virtualenv
	# If not possible, this will error out with: ERR_CANNOT_CREATE_VIRTUALENV
	unsafe_dpv_internal_create_virtualenv

	if dpv_check_is_set "$INTERNAL_ARG_DEPS"; then
		# Install dependnecies
		# If not possible, this will error out with: ERR_CANNOT_INSTALL_DEPENDENCIES
		unsafe_dpv_internal_install_deps
	fi

	INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir="$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir"
}

unsafe_dpv_internal_install_deps() {
	case "$INTERNAL_INITIALIZE_VIRTUALENV_install_method" in
	UV)
		cd "$INTERNAL_UV_PROJECT_DIR"
		if ! dpv_check_is_set "$DPV_MOCK_UV_INSTALL"; then
			uv_install="$CFG_UV_EXECUTABLE add"
		else
			uv_install="$DPV_MOCK_UV_INSTALL"
		fi
		fail="$(dpv_make_temp_file)"
		echo "uv: installing dependencies"
		( ($uv_install setuptools "$INTERNAL_ARG_DEPS" 2>&1) || echo >"$fail") | dpv_pipe_quote
		if [ ! -s "$fail" ]; then
			echo "uv: done"
		else
			dpv_pipe_quote <"$fail"
			echo "uv: failed"
			exit "$ERR_CANNOT_INSTALL_DEPENDENCIES"
		fi
		;;
	*)
		if ! dpv_check_is_set "$DPV_MOCK_PIP"; then
			pip="$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir/bin/python -m pip"
		else
			pip="$DPV_MOCK_PIP"
		fi
		fail="$(dpv_make_temp_file)"
		echo "pip: installing dependencies"
		( ($pip install setuptools $INTERNAL_ARG_DEPS 2>&1) || echo >"$fail") | dpv_pipe_quote
		if [ ! -s "$fail" ]; then
			echo "pip: done"
		else
			dpv_pipe_quote <"$fail"
			echo "pip: failed"
			exit "$ERR_CANNOT_INSTALL_DEPENDENCIES"
		fi
		;;
	esac
}

unsafe_dpv_internal_create_virtualenv() {
	#
	# Creates a new virtualenv
	#
	# Unsafe:
	# - unsafe_dpv_internal_${install_method}_install
	# - ERR_CANNOT_CREATE_VIRTUALENV
	#
	if [ "${ARG_TEMP:-}" = "1" ]; then
		case "$INTERNAL_INITIALIZE_VIRTUALENV_install_method" in
		UV)
            INTERNAL_UV_PROJECT_DIR="$(dpv_make_temp_dir)"
			INTERNAL_CREATE_VIRTUALENV_virtualenv_dir="$INTERNAL_UV_PROJECT_DIR/.venv"
			mv "$(dpv_internal_mkdir_virtualenv_temporary)" "$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir"
            tmpname="$(basename "$INTERNAL_UV_PROJECT_DIR")"
			printf "[project]\nname = \"%s\"\nversion = \"0.0.0\"\nrequires-python = \"==%s\"\n" "$tmpname" "$INTERNAL_INITIALIZE_VIRTUALENV_python_version" >"$INTERNAL_UV_PROJECT_DIR/pyproject.toml"
			;;
		*)
			INTERNAL_CREATE_VIRTUALENV_virtualenv_dir=$(dpv_internal_mkdir_virtualenv_temporary)
            tmpname="$(basename "$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir")"
			;;
		esac
	else
		INTERNAL_CREATE_VIRTUALENV_virtualenv_dir=$(dpv_internal_mkdir_virtualenv)
	fi

	vendor_prefix="$(dpv_string_lowercase "$INTERNAL_INITIALIZE_VIRTUALENV_install_method"):"

	echo "$vendor_prefix creating virtualenv..."
	func=$(eval "echo \"unsafe_dpv_internal_\"$INTERNAL_INITIALIZE_VIRTUALENV_install_method\"_create_virtualenv\"")

	fail="$(dpv_make_temp_file)"
	( (eval "$($func)" 2>&1) || echo >"$fail") | dpv_pipe_quote
	if [ ! -s "$fail" ]; then
		printf "path = %s\nversion = %s\ninstall_method = %s\n" "$PWD" "$INTERNAL_INITIALIZE_VIRTUALENV_python_version" "$INTERNAL_INITIALIZE_VIRTUALENV_install_method" >"$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir/dpv.cfg"
		dpv_internal_log "created new virtualenv: $tmpname"
		echo "$vendor_prefix done"
	else
		rm -rf "$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir"
		echo "$vendor_prefix error"
		exit "$ERR_CANNOT_CREATE_VIRTUALENV"
	fi
}

dpv_internal_resolve_python_version() {
	#
	# Tries to resolve a given Python version matching with:
	# 1. An already installed Python version
	# 2. An available Python version
	#
	initial_version="$1"
	from_installed=""
	from_installed_version=""
	from_available=""
	from_available_version=""

	# Find matching Python versions among installed and available
	while IFS= read -r line; do
		for install in $line; do
			installed_python_versions_func=$(eval "echo \"dpv_internal_\"$install\"_installed_python_versions\"")
			available_python_versions_func=$(eval "echo \"dpv_internal_\"$install\"_available_python_versions\"")

			eval "$installed_python_versions_func"
			eval "$available_python_versions_func"

			installed_versions_var="INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS"
			available_versions_var="INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS"

			installed_versions=$(eval "echo \"\$$installed_versions_var\"")
			available_versions=$(eval "echo \"\$$available_versions_var\"")

			func=$(eval "echo \"dpv_internal_\"\$install\"_resolve_python_version\"")
			resolved_version=$(
				eval "$func" <<EOF
$initial_version
EOF
			)
			if dpv_check_string_is_empty "$resolved_version"; then
				continue
			fi

			case "$installed_versions" in
			*"$resolved_version"*)
				from_installed="$install"
				from_installed_version="$resolved_version"
				break 2
				;;
			esac
			case "$available_versions" in
			*"$resolved_version"*)
				from_available="$install"
				from_available_version="$resolved_version"
				;;
			esac
		done
	done <<EOF
$INTERNAL_AVAILABLE_INSTALL_METHODS
EOF

	if ! dpv_check_string_is_empty "$from_installed"; then
		# Give precedence to already installed Python versions, if any matches
		INTERNAL_RESOLVE_INSTALL_METHOD="$from_installed"
		INTERNAL_RESOLVE_PYTHON_VERSION="$from_installed_version"

		dpv_internal_log "$from_installed method selected"
		if [ "$initial_version" != "$INTERNAL_RESOLVE_PYTHON_VERSION" ]; then
			dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: resolved version $initial_version -> $INTERNAL_RESOLVE_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: version $from_installed_version already installed"

	elif ! dpv_check_string_is_empty "$from_available"; then
		# Otherwise offer an available Python version that needs to be installed, if any matches
		INTERNAL_RESOLVE_INSTALL_METHOD="$from_available"
		INTERNAL_RESOLVE_PYTHON_VERSION="$from_available_version"

		dpv_internal_log "$from_available method selected"
		if [ "$initial_version" != "$INTERNAL_RESOLVE_PYTHON_VERSION" ]; then
			dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: resolved version $initial_version -> $INTERNAL_RESOLVE_PYTHON_VERSION"
		fi
		dpv_internal_log "$INTERNAL_RESOLVE_INSTALL_METHOD: version $from_available_version needs to be installed"

	else
		# If there are not matches among installed and available Python versions
		return 1
	fi
}

dpv_internal_scan_virtualenv() {
	#
	# Tries to find an existing virtualenv for the project
	# The virtualenvs directory has the following tree layout:
	#
	# + root (stored in variable: CFG_VIRTUALENVS_DIR)
	#  \
	#   - venv-dir-1
	#   - venv-dir-2
	#   + venv-dir-3
	#    \
	#     + dpv.cfg
	#      \
	#       |------ file format ------|
	#       |-------------------------|
	#       | path = /path/to/project |
	#       | version = 3.9.2         | --> this is the Python version
	#       | install_method = PYENV  |
	#       |-------------------------|
	#
	found_virtualenv_dir="ø"
	found_version=""
	found_install_method=""

	# try to locate existing virtualenv
	virtualenvs_output="$(dpv_internal_find_virtualenvs)"
	if dpv_check_string_is_empty "$virtualenvs_output"; then
		return 1
	fi

	while IFS= read -r virtualenv_dir; do
		dpv_internal_parse_virtualenv_config_file "$virtualenv_dir/dpv.cfg"

		match_python_version=0
		if dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION"; then
			case "$INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_version" in
			"$INTERNAL_ARG_PYTHON_VERSION"*)
				match_python_version=1
				;;
			esac
		else
			match_python_version=1
		fi

		if [ "$match_python_version" -eq 1 ]; then
			if ! dpv_check_is_set "$found_virtualenv_dir"; then
				dpv_internal_log "found virtualenv: $(basename "$virtualenv_dir")"
				found_version=$INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_version
				found_install_method=$INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_install_method
				found_virtualenv_dir=$virtualenv_dir
			else
				dpv_internal_log "found virtualenv: $(basename "$virtualenv_dir") (skipped)"
			fi
		fi
	done <<EOF
$virtualenvs_output
EOF
	if dpv_check_is_set "$found_virtualenv_dir"; then
		INTERNAL_SCAN_VIRTUALENV_virtualenv_dir="$found_virtualenv_dir"
		INTERNAL_SCAN_VIRTUALENV_version="$found_version"
		INTERNAL_SCAN_VIRTUALENV_install_method="$found_install_method"
	else
		return 1
	fi
}

dpv_internal_find_virtualenvs() {
	if [ ! -d "$CFG_VIRTUALENVS_DIR" ]; then
		return
	fi

	output="$(find "$CFG_VIRTUALENVS_DIR" -name dpv.cfg -type f -mindepth 3 -maxdepth 3)"
	while IFS= read -r file; do
		dpv_internal_parse_virtualenv_config_file "$file"

		if [ "$INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_path" = "$PWD" ]; then
			dirname "$file"
		fi
	done <<EOF
$output
EOF
}

dpv_internal_scan_python_version() {
	#
	# Tries to find the required Python version for a project in the following order:
	# 1. Check if a Python version was passed by argument
	# 2. Check if there is a runtime.txt file
	# 3. Check if there is a pyproject.toml file with a Python version
	# 4. Check if there is a Python version already installed with one of the install methods
	# 5. Check if there is a Python version available with one of the install methods
	#

	# use version provided by the user, if provided
	if dpv_check_is_set "$INTERNAL_ARG_PYTHON_VERSION"; then
		INTERNAL_SCAN_PYTHON_VERSION_source="command-line"
		INTERNAL_SCAN_PYTHON_VERSION_version="$INTERNAL_ARG_PYTHON_VERSION"
		return
	fi

	# use version from runtime.txt, if available
	if [ -f "runtime.txt" ]; then
		INTERNAL_SCAN_PYTHON_VERSION_source="runtime.txt"
		INTERNAL_SCAN_PYTHON_VERSION_version="$(dpv_string_regex_replace "$(cat runtime.txt)" "^python\-" "")"
		return
	fi

	# use version from pyproject.toml, if available
	if [ -f "pyproject.toml" ]; then
		while IFS= read -r line; do
			case "$line" in
			"requires-python = "* | "python = "*)
				INTERNAL_SCAN_PYTHON_VERSION_source="pyproject.toml"
				INTERNAL_SCAN_PYTHON_VERSION_version="$(
					sed -E 's/.*python = ("[^0-9]*(.*)"|'"'"'[^0-9]*(.*)'"'"'|[^0-9]*(.*))/\2\3\4/' <<EOF
$line
EOF
				)"
				return
				;;
			esac
		done <"pyproject.toml"

		return
	fi

	# find installed version, if any
	version_found="ø"
	while IFS= read -r line; do
		for install in $line; do
			func=$(eval "echo \"dpv_internal_\"\$install\"_installed_python_versions\"")
			eval "$func"
			versions_var="INTERNAL_${install}_INSTALLED_PYTHON_VERSIONS"
			installed_versions=$(eval "echo \"\$$versions_var\"")
			if ! dpv_check_string_is_empty "$installed_versions"; then
				while read -r version; do
					INTERNAL_SCAN_PYTHON_VERSION_source="already installed with $(dpv_string_lowercase "$install")"
					INTERNAL_SCAN_PYTHON_VERSION_version="$version"
					version_found=$version
					return
				done <<EOF
$installed_versions
EOF
			fi
		done
	done <<EOF
$INTERNAL_AVAILABLE_INSTALL_METHODS
EOF

	# find available version, if any
	if ! dpv_check_is_set "$version_found"; then
		while IFS= read -r line; do
			for install in $line; do
				func=$(eval "echo \"dpv_internal_\"\$install\"_available_python_versions\"")
				eval "$func"
				versions_var="INTERNAL_${install}_AVAILABLE_PYTHON_VERSIONS"
				available_versions=$(eval "echo \"\$$versions_var\"")
				if ! dpv_check_string_is_empty "$available_versions"; then
					while read -r version; do
						INTERNAL_SCAN_PYTHON_VERSION_source="can be installed with $(dpv_string_lowercase "$install")"
						INTERNAL_SCAN_PYTHON_VERSION_version="$version"
						return
					done <<EOF
$available_versions
EOF
				fi
			done
		done <<EOF
$INTERNAL_AVAILABLE_INSTALL_METHODS
EOF
	fi

	return 1
}

dpv_internal_parse_virtualenv_config_file() {
	#
	# Parses the given configuration file (dpv.cfg)
	#
	config_file="$1"

	_path=""
	_version=""
	_install_method=""

	while IFS= read -r line; do
		case "$line" in
		"path = "*)
			_path="$(
				sed -E 's/path = (.*)/\1/' <<EOF
$line
EOF
			)"
			;;
		"version = "*)
			_version="$(
				sed -E 's/version = (.*)/\1/' <<EOF
$line
EOF
			)"
			;;
		"install_method = "*)
			_install_method="$(
				sed -E 's/install_method = (.*)/\1/' <<EOF
$line
EOF
			)"
			;;
		esac
	done <"$config_file"

	INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_path="$_path"
	INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_version="$_version"
	INTERNAL_PARSE_VIRTUALENV_CONFIG_FILE_install_method="$_install_method"

	missing=""
	if dpv_check_string_is_empty "$_path"; then missing="$missing, path"; fi
	if dpv_check_string_is_empty "$_version"; then missing="$missing, version"; fi
	if dpv_check_string_is_empty "$_install_method"; then missing="$missing, install_method"; fi

	if ! dpv_check_string_is_empty "$missing"; then
		missing="$(
			dpv_string_lstrip 2 <<EOF
$missing
EOF
		)"
		dpv_internal_log "virtualenv config file missing: $missing (file: $config_file)"
		return 1
	fi
}

#
# Main function
#

dpv_internal_main() {
	#
	# Main
	#
	trap 'dpv_internal_error_handling $?' EXIT

	CMD=""
	CMD_ARGS=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		--uv)
			ARG_USE_UV=1
			;;
		--pyenv)
			ARG_USE_PYENV=1
			;;
		--homebrew | --brew)
			ARG_USE_HOMEBREW=1
			;;
		--list)
			CMD="list"
			;;
		--info)
			CMD="info"
			;;
		--help)
			CMD="help"
			;;
		--*)
			CMD_ARGS="$CMD_ARGS $i"
			;;
		*)
			if [ "$CMD" = "" ]; then
				CMD="$i"
			else
				CMD_ARGS="$CMD_ARGS $i"
			fi
			;;
		esac
	done

	# drop leading space
	CMD_ARGS=$(
		cut -c2- <<EOF
$CMD_ARGS
EOF
	)

	# must happen after ARG_ variables are parsed
	if [ "${ARG_USE_UV:-}" = "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="UV"
	elif [ "${ARG_USE_PYENV:-}" = "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="PYENV"
	elif [ "${ARG_USE_HOMEBREW:-}" = "1" ]; then
		CFG_PREFERRED_INSTALL_METHODS="HOMEBREW"
	fi

	dpv_internal_set_log_file

	case "$CMD" in
	internal-eval)
		#DPV-INTERNAL-EVAL#
		;;

	internal-load-shell)
		unsafe_dpv_cmd_internal_load_shell
		;;

	list | --list | ls | -l)
		dpv_cmd_list | dpv_pipe_format_theme
		;;

	info)
		unsafe_dpv_internal_cmd_info | dpv_pipe_format_theme
		;;

	2* | 3* | 4*)
		case "$CMD_ARGS" in
		*"--python"*)
			trap - EXIT
			echo "error: dpv cannot run \"dpv [version]\" with \"--python\" - use one or the other" | dpv_pipe_format_theme
			exit "$ERR_MAIN_INVALID_ARGUMENT"
			;;
		esac

		# shellcheck disable=2086
		unsafe_dpv_internal_cmd_run_wrapper --python "$CMD" $CMD_ARGS
		;;

	run | "")
		# shellcheck disable=2086
		unsafe_dpv_internal_cmd_run_wrapper "$CMD_ARGS"
		;;

	try)
		unsafe_dpv_cmd_try $CMD_ARGS
		;;

	versions | -v)
		# shellcheck disable=2086
		dpv_internal_cmd_versions "$CMD_ARGS" | dpv_pipe_format_theme
		;;

	drop | rm)
		set -o noglob
		set -- "$CMD_ARGS"
		# shellcheck disable=SC2068
		dpv_internal_cmd_drop $@ | dpv_pipe_format_theme
		;;

	help | --help | -h)
		dpv_cmd_help | dpv_pipe_format_theme
		;;

	*)
		echo "error: dpv invalid subcommand: $CMD" | dpv_pipe_format_theme
		exit "$ERR_MAIN_INVALID_ARGUMENT"
		;;

	esac
}

#
# Error-handling
#

dpv_internal_error_handling() {
	#
	# Handled error codes
	#
	case "$1" in

	"$ERR_MAIN_INVALID_ARGUMENT")
		echo "dpv - invalid argument"
		;;

	"$ERR_INSTALL_METHOD_NOT_SELECTED")
		echo "dpv - no installation method selected"
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		echo "dpv - failed to activate virtualenv $INTERNAL_INITIALIZE_VIRTUALENV_virtualenv_dir"
		;;

	"$ERR_RUN_INVALID_ARGUMENT")
		echo "dpv - invalid argument passed to run"
		;;

	"$ERR_TRY_MISSING_DEPENDENCY_ARG")
		echo "dpv - the try command requires one package as the first argument"
		;;

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		echo "dpv - failed to determine python version for $PWD"
		;;

	"$ERR_NO_AVAILABLE_INSTALL_METHODS")
		echo "dpv - no installation methods available"
		;;

	"$ERR_CANNOT_RESOLVE_PYTHON_VERSION")
		echo "dpv - cannot resolve python version"
		;;

	"$ERR_CANNOT_CREATE_VIRTUALENV")
		echo "dpv - failed to create virtualenv"
		;;

	"$ERR_CANNOT_INSTALL_DEPENDENCIES")
		echo "dpv - failed to install dependencies"
		;;

	"$ERR_VIRTUALENV_INSTALL_METHOD_NOT_AVAILABLE")
		echo "dpv - installation method defined by the virtualenv is not available"
		;;

	"$ERR_INSTALLATION_FAILED")
		echo "dpv - failed to install python version"
		;;

	esac

	dpv_internal_print_logs | dpv_pipe_format_theme
}

#
# uv utils
#
dpv_UV_is_available() {
	#
	# Check if uv is installed
	#
	dpv_command_exists "$CFG_UV_EXECUTABLE"
}

dpv_UV_exec() {
	#
	# Wrapper around the uv executable
	#
	$CFG_UV_EXECUTABLE "$@"
}

dpv_internal_UV_resolve_python_version() {
	#
	# Matches the given Python versions with the versions in uv
	#
	while read -r line; do
		resolved_version=""
		available_version="none"
		major_version="$(
			cut -d. -f1,2 <<EOF
$line
EOF
		)"

		# Tries to match with installed Python versions
		dpv_internal_UV_installed_python_versions
		while IFS= read -r version; do
			case "$version" in
			"$line"*)
				resolved_version=$version
				break
				;;
			"$major_version"*)
				available_version=$version
				;;
			esac
		done <<EOF
$INTERNAL_UV_INSTALLED_PYTHON_VERSIONS
EOF

		# Tries to match with available Python versions
		dpv_internal_UV_available_python_versions
		if dpv_check_string_is_empty "$resolved_version"; then
			while IFS= read -r version; do
				case "$version" in
				"$line"*)
					resolved_version=$version
					break
					;;
				"$major_version"*)
					available_version=$version
					;;
				esac
			done <<EOF
$INTERNAL_UV_AVAILABLE_PYTHON_VERSIONS
EOF
		fi

		if ! dpv_check_string_is_empty "$resolved_version"; then
			echo "$resolved_version"
		elif [ "$available_version" != "none" ]; then
			echo "$available_version"
		fi
	done
}

dpv_internal_UV_installed_python_versions() {
	#
	# Lists the installed Python versions in uv
	#
	dpv_check_is_set "$INTERNAL_UV_INSTALLED_PYTHON_VERSIONS" && return

	INTERNAL_UV_INSTALLED_PYTHON_VERSIONS="$(dpv_internal_run_command_log_failure "$CFG_UV_EXECUTABLE python list --only-installed" | while IFS= read -r line; do
		cut -d- -f2 <<EOF | uniq
$line
EOF
	done | dpv_pipe_sort_version)"

	if dpv_check_string_is_empty "$INTERNAL_UV_INSTALLED_PYTHON_VERSIONS"; then
		return 1
	fi
}

dpv_internal_UV_available_python_versions() {
	#
	# Lists the available Python versions in uv
	#
	dpv_check_is_set "$INTERNAL_UV_AVAILABLE_PYTHON_VERSIONS" && return

	INTERNAL_UV_AVAILABLE_PYTHON_VERSIONS="$(
		dpv_internal_run_command_log_failure "$CFG_UV_EXECUTABLE python list --all-versions" | cut -d- -f2 | dpv_pipe_sort_version
		echo
	)"

	if dpv_check_string_is_empty "$INTERNAL_UV_AVAILABLE_PYTHON_VERSIONS"; then
		return 1
	fi
}

unsafe_dpv_internal_UV_create_virtualenv() {
	virtualenv_dir="$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir"
	python_executable="$(unsafe_dpv_internal_UV_get_python_executable)"

	dpv_UV_exec venv --python "$python_executable" "$virtualenv_dir"
}

unsafe_dpv_internal_UV_get_python_executable() {
	#
	# Gets the Python executable for the current virtualenv
	#
	# Unsafe:
	# - ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE
	#
	if prefix="$(dpv_UV_exec python find "$INTERNAL_INITIALIZE_VIRTUALENV_python_version")"; then
		echo "$prefix"
		return
	fi
	exit "$ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE"
}

unsafe_dpv_internal_UV_install() {
	#
	# Install Python version using uv
	#
	# Unsafe:
	# - ERR_INSTALLATION_FAILED
	#
	while IFS= read -r python_version; do
		case "$INTERNAL_UV_INSTALLED_PYTHON_VERSIONS" in
		*"$python_version"*)
			continue
			;;
		esac

		echo "installing python $python_version using uv"
		fail="$(dpv_make_temp_file)"
		(dpv_UV_exec python install "$python_version" 2>&1 || echo >"$fail") | dpv_pipe_quote
		if [ ! -s "$fail" ]; then
			echo "done"
		else
			echo "failed"
			dpv_internal_log "uv: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

#
# Pyenv utils
#
dpv_PYENV_is_available() {
	#
	# Check if pyenv is installed
	#
	dpv_command_exists "$CFG_PYENV_EXECUTABLE"
}

dpv_PYENV_exec() {
	#
	# Wrapper around the pyenv executable
	#
	$CFG_PYENV_EXECUTABLE "$@"
}

unsafe_dpv_internal_PYENV_create_virtualenv() {
	virtualenv_dir="$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir"
	python_executable="$(unsafe_dpv_internal_PYENV_get_python_executable)"

	"$python_executable" -m venv "$virtualenv_dir"
}

unsafe_dpv_internal_PYENV_install() {
	#
	# Install Python version using pyenv
	#
	# Unsafe:
	# - ERR_INSTALLATION_FAILED
	#
	while IFS= read -r python_version; do
		case "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" in
		*"$python_version"*)
			continue
			;;
		esac

		echo "installing python $python_version using pyenv"
		fail="$(dpv_make_temp_file)"
		(dpv_PYENV_exec install "$python_version" 2>&1 || echo >"$fail") | dpv_pipe_quote
		if [ ! -s "$fail" ]; then
			echo "done"
		else
			echo "failed"
			dpv_internal_log "pyenv: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

unsafe_dpv_internal_PYENV_get_python_executable() {
	#
	# Gets the Python executable for the current virtualenv
	#
	# Unsafe:
	# - ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE
	#
	if prefix="$(dpv_PYENV_exec prefix "$INTERNAL_INITIALIZE_VIRTUALENV_python_version")"; then
		if [ -d "$prefix" ]; then
			cmd="$prefix/bin/python"
			if [ -x "$cmd" ]; then
				echo "$cmd"
				return
			fi
		fi
	fi
	exit "$ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE"
}

dpv_internal_PYENV_installed_python_versions() {
	#
	# Lists the installed Python versions in pyenv
	#
	dpv_check_is_set "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS="$(dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE versions --bare --skip-aliases" | while IFS= read -r line; do
		cut -d/ -f1 <<EOF | uniq
$line
EOF
	done | dpv_pipe_sort_version)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS"; then
		return 1
	fi
}

dpv_internal_PYENV_available_python_versions() {
	#
	# Lists the available Python versions in pyenv
	#
	dpv_check_is_set "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS" && return

	INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS="$(
		dpv_internal_run_command_log_failure "$CFG_PYENV_EXECUTABLE install --list" | grep '^ ' | tr -d ' ' | dpv_pipe_sort_version
		echo
	)"

	if dpv_check_string_is_empty "$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS"; then
		return 1
	fi
}

dpv_internal_PYENV_resolve_python_version() {
	#
	# Matches the given Python versions with the versions in pyenv
	#
	while read -r line; do
		resolved_version=""
		available_version="none"
		major_version="$(
			cut -d. -f1,2 <<EOF
$line
EOF
		)"

		# Tries to match with installed Python versions
		dpv_internal_PYENV_installed_python_versions
		while IFS= read -r version; do
			case "$version" in
			"$line"*)
				resolved_version=$version
				break
				;;
			"$major_version"*)
				available_version=$version
				;;
			esac
		done <<EOF
$INTERNAL_PYENV_INSTALLED_PYTHON_VERSIONS
EOF

		# Tries to match with available Python versions
		dpv_internal_PYENV_available_python_versions
		if dpv_check_string_is_empty "$resolved_version"; then
			while IFS= read -r version; do
				case "$version" in
				"$line"*)
					resolved_version=$version
					break
					;;
				"$major_version"*)
					available_version=$version
					;;
				esac
			done <<EOF
$INTERNAL_PYENV_AVAILABLE_PYTHON_VERSIONS
EOF
		fi

		if ! dpv_check_string_is_empty "$resolved_version"; then
			echo "$resolved_version"
		elif [ "$available_version" != "none" ]; then
			echo "$available_version"
		fi
	done
}

#
# Homebrew utils
#
dpv_HOMEBREW_is_available() {
	#
	# Gets the executable for homebrew
	#
	dpv_command_exists "$CFG_HOMEBREW_EXECUTABLE"
}

unsafe_dpv_internal_HOMEBREW_install() {
	#
	# Installs Python version with homebrew
	#
	# Unsafe:
	# - ERR_INSTALLATION_FAILED
	#
	while IFS= read -r python_version; do
		case "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" in
		*"$python_version"*)

			continue
			;;
		esac
		echo "installing python $python_version using homebrew"
		fail="$(dpv_make_temp_file)"
		(dpv_HOMEBREW_exec install "$(dpv_HOMEBREW_format_python_formula "$python_version")" 2>&1 || echo >"$fail") | dpv_pipe_quote
		if [ ! -s "$fail" ]; then
			echo "done"
		else
			echo "failed"
			dpv_internal_log "homebrew: failed to install version $python_version"
			exit "$ERR_INSTALLATION_FAILED"
		fi
	done
}

dpv_HOMEBREW_exec() {
	#
	# Wrapper around the homebrew executable
	#
	HOMEBREW_NO_AUTO_UPDATE=1 "$CFG_HOMEBREW_EXECUTABLE" "$@"
}

unsafe_dpv_internal_HOMEBREW_create_virtualenv() {
	virtualenv_dir="$INTERNAL_CREATE_VIRTUALENV_virtualenv_dir"
	python_executable="$(unsafe_dpv_internal_HOMEBREW_get_python_executable)"

	"$python_executable" -m venv "$virtualenv_dir"
}

unsafe_dpv_internal_HOMEBREW_get_python_executable() {
	#
	# Gets path to Python executable installed with homebrew
	#
	cmd="$(dpv_HOMEBREW_exec --prefix "$(dpv_HOMEBREW_format_python_formula "$INTERNAL_INITIALIZE_VIRTUALENV_python_version")" 2>/dev/null)"/libexec/bin/python
	if [ -x "$cmd" ]; then
		echo "$cmd"
	else
		exit "$ERR_VIRTUALENV_CANNOT_FIND_PYTHON_EXECUTABLE"
	fi
}

dpv_internal_HOMEBREW_installed_python_versions() {
	#
	# Gets list of Python versions available with homebrew
	#
	dpv_check_is_set "$INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS" && return

	dpv_internal_HOMEBREW_available_python_versions

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE list" | grep 'python@' | cut -d@ -f2 | dpv_HOMEBREW_pipe_expand_python_version | dpv_pipe_sort_version); then
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_INSTALLED_PYTHON_VERSIONS=""
		return 1
	fi
}

dpv_internal_HOMEBREW_available_python_versions() {
	#
	# Gets list of available Python versions in homebrew
	#
	dpv_check_is_set "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" && return

	if result=$(dpv_internal_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE search python"); then
		result=$(echo "$result" | grep -o 'python@[^ ]\+' | cut -d@ -f2 | dpv_HOMEBREW_pipe_expand_python_version | dpv_pipe_sort_version)
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=$result
	else
		INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS=""
		return 1
	fi
}

dpv_HOMEBREW_format_python_formula() {
	#
	# Gets the Python homebrew formula for the given version
	#
	version="$1"
	echo "python@$(
		cut -d. -f1,2 <<EOF
$version
EOF
	)"
}

dpv_internal_HOMEBREW_resolve_python_version() {
	#
	# Matches the given Python versions with the versions available in homebrew
	#
	dpv_internal_HOMEBREW_available_python_versions

	while read -r line; do
		available_version="none"
		major_version="$(
			cut -d. -f1,2 <<EOF
$line
EOF
		)"
		if [ "$line" = "$major_version" ]; then
			case "$INTERNAL_HOMEBREW_AVAILABLE_PYTHON_VERSIONS" in
			*"$major_version"*)

				dpv_HOMEBREW_pipe_expand_python_version <<EOF
$major_version
EOF
				continue
				;;
			esac
		else
			version=$(
				dpv_HOMEBREW_pipe_expand_python_version <<EOF
$major_version
EOF
			)
			if [ "$version" = "$line" ]; then
				echo "$version"
				continue
			fi
		fi
	done
}

dpv_HOMEBREW_pipe_expand_python_version() {
	#
	# Expands Python version provided by homebrew
	# Homebrew only provides major Python versions, this will return the full version
	# Example: 3.9 -> 3.9.12
	#
	while read -r line; do
		major_version="$(
			cut -d. -f1,2 <<EOF
$line
EOF
		)"
		formula_path="$(dpv_HOMEBREW_exec edit "$(dpv_HOMEBREW_format_python_formula "$major_version")" --print-path 2>/dev/null)" || return 1
		grep -o "$major_version\.[0-9]\+[a-z]*" "$formula_path" | while IFS= read -r version; do
			echo "$version"
			break
		done
	done
}

#
# Internals
#
dpv_internal_mkdir_virtualenv() {
	#
	# Create a new virtualenv directory
	#
	dirname="$CFG_VIRTUALENVS_DIR/$INTERNAL_INITIALIZE_VIRTUALENV_python_version/$(basename "$PWD")-$INTERNAL_INITIALIZE_VIRTUALENV_python_version"
	mkdir -p "$dirname"
	printf "%s" "$dirname"
}

dpv_internal_mkdir_virtualenv_temporary() {
	#
	# Create a new *temporary* virtualenv directory
	#
	dpv_make_temp_dir "$(basename "$PWD")-$INTERNAL_INITIALIZE_VIRTUALENV_python_version"
}

dpv_internal_set_log_file() {
	#
	# Sets up the log file
	#
	dpv_check_is_set "$INTERNAL_LOG_FILE" && return

	INTERNAL_LOG_FILE=$(dpv_make_temp_file "dpv_log")
}

unsafe_dpv_internal_set_available_install_methods() {
	#
	# Sets up the install methods that are available
	#
	# Unsafe:
	# - ERR_NO_AVAILABLE_INSTALL_METHODS
	#
	dpv_check_is_set "$INTERNAL_AVAILABLE_INSTALL_METHODS" && return

	INTERNAL_AVAILABLE_INSTALL_METHODS="$(for install in $(dpv_string_uppercase "$CFG_PREFERRED_INSTALL_METHODS"); do
		func=$(eval "echo \"dpv_${install}_is_available\"")
		if eval "$func"; then
			echo "$install"
		fi
	done)"

	if dpv_check_string_is_empty "$INTERNAL_AVAILABLE_INSTALL_METHODS"; then
		exit "$ERR_NO_AVAILABLE_INSTALL_METHODS"
	fi
}

dpv_internal_run_command_log_failure() {
	#
	# Executes a command and logs the output
	# In case of failure, displays the output
	#
	tmpfile=$(dpv_make_temp_file)
	if "$(dpv_current_shell)" -c "$@" >"$tmpfile"; then
		cat "$tmpfile"
		return 0
	else
		dpv_internal_log "failed to run command: $*"
		printf "%s\n" "$(dpv_pipe_quote <"$tmpfile")" >>"$INTERNAL_LOG_FILE"
		return 1
	fi
}

dpv_internal_log() {
	#
	# Prints a log mesage to the log file
	#
	printf "%s\n" "$*" >>"$INTERNAL_LOG_FILE"
}

dpv_internal_pipe_format_python_versions() {
	# Input is a pipe with multiple lines *already sorted*, every line is a version
	# Outputs multiple lines, every line is a version
	#
	# For each version in input, return the best candidate:
	# 1. The exact same version is installed: 3.9.1* (star means it is installed)
	# 2. Another minor version is installed: 3.9.2*
	# 3. Another major version is installed: 3.9*
	# 4. Otherwise return the version without the star: 3.8
	#
	# Versions should be de-duplicated by its major version
	# For these versions: 3.9.1 3.9.2 3.8 3.7.1
	# Only one for each major is returned: 3.9.1* 3.8 3.7.1
	# Except, when the --all parameter is passed!
	# In that case, all versions are returned: 3.9.1* 3.9.2 3.8 3.7.1

	_install_method="$1"
	_options="${2:-}"

	installed_versions_var="INTERNAL_${_install_method}_INSTALLED_PYTHON_VERSIONS"
	installed_versions=$(eval "echo \"\$$installed_versions_var\"")

	case " $_options " in
	*" --all "*)

		while IFS= read -r line; do
			# If it is installed, add a star to it
			for version in $installed_versions; do
				if [ "$version" = "$line" ]; then
					echo "$version*"
					continue 2
				fi
			done

			# Otherwise, no star
			echo "$line"
		done
		;;
	*)
		skip=""
		while IFS= read -r version; do
			major_version="$(
				dpv_pipe_format_major_version <<EOF
$version
EOF
			)"

			# Skip in case this major version has already been seen
			case " $skip " in
			*" $major_version "*)
				continue
				;;
			*)
				skip="$skip $major_version"
				;;
			esac

			# Check if it matches any installed versions (exact or similar)
			is_installed=0
			is_exact_match=0
			similar_version=""
			for installed_version in $installed_versions; do
				case "$installed_version" in
				"$version")
					is_installed=1
					is_exact_match=1
					break
					;;
				"$major_version."*)
					is_installed=1
					similar_version="$installed_version"
					;;
				"$major_version")
					is_installed=1
					similar_version="$major_version"
					;;
				esac
			done

			# If there is an exact match, use it, otherwise use the similar
			if [ $is_exact_match -eq 1 ]; then
				echo "$version*"
			elif [ $is_installed -eq 1 ]; then
				echo "$similar_version*"
			else
				# In case it is not installed, return the version as is
				# Unless it is not a mainstream version
				grep -Ee '^(3\.[7-9]+[0-9]*|3\.[1-9]+[0-9]*)' <<EOF | grep -Ev 'dev|rc' || continue
$version
EOF

			fi
		done
		;;
	esac
}

#
# General utils
#
dpv_current_shell() {
	#
	# Get the current shell
	# Example: bash, /bin/sh
	#
	# shellcheck disable=SC2009

	output="$(dpv_make_temp_file)"
	ps -opid,args >"$output" || (
		# https://github.com/actions/runner-images/issues/3462
		echo "/bin/sh"
		exit 0
	)

	while IFS= read -r line; do
		# shellcheck disable=SC2086
		set -- $(printf "%s" "$line")
		[ "$1" = "$$" ] || continue
		shift
		for arg in "$@"; do
			case "$arg" in
			"{"*)
				# skip curly braces used by busybox
				# https://www.theunterminatedstring.com/busybox-ps-brackets-and-braces/
				continue
				;;
			*)
				echo "$arg"
				break 2
				;;
			esac
		done
	done <"$output"
}

dpv_command_exists() {
	command -v "$1" 1>/dev/null
}

dpv_make_temp_file() {
	#
	# Creates a temporary file
	#
	suffix="${1-}"
	if dpv_check_string_is_empty "$suffix"; then
		template="${TMPDIR:-/tmp/}dpv.XXXXXX"
	else
		template="${TMPDIR:-/tmp/}$suffix.XXXXXX"
	fi
	mktemp "$template"
}

dpv_make_temp_dir() {
	#
	# Creates a temporary directory
	#
	suffix="${1-}"
	if dpv_check_string_is_empty "$suffix"; then
		template="${TMPDIR:-/tmp/}dpv.XXXXXX"
	else
		template="${TMPDIR:-/tmp/}$suffix.XXXXXX"
	fi
	mktemp -d "$template"
}

dpv_pipe_sort_path() {
	#
	# Sort paths by the given index position
	#
	index="$1"

	# -f = ignore case
	# -t = field separator
	# -k = field position
	sort -f -t/ -k "$index"
}

dpv_pipe_sort_version() {
	#
	# Sort versions
	#
	# -t = field separator
	# -k = field position
	#
	# n modifier: consider numeric
	# r modifier: reverse order
	sort -t. -k1,1nr -k2,2nr -k3,3nr
}

dpv_pipe_format_nl_to_space() {
	#
	# Replaces newlines with spaces
	#
	tr '\n' ' '
}

dpv_pipe_format_major_version() {
	#
	# Returns the major version for the given version
	# Example: 3.9.12 -> 3.9
	#
	cut -d. -f1,2
}

dpv_pipe_format_theme() {
	#
	# Applies theme to the output
	#
	"$CFG_THEME"
}

dpv_pipe_quote() {
	#
	# Quote output
	#
	prefix="${1:->}"
	sed "s/^/  $prefix /"
}

dpv_check_file_is_empty() {
	#
	# Check if file is empty
	#
	# -s :: Size is > 0 bytes
	! [ -s "$1" ]
}

dpv_check_string_is_empty() {
	#
	# Check if string is empty
	#
	# -z :: String is empty
	[ -z "${1:-}" ]
}

dpv_check_is_set() {
	#
	# Check if variable is set
	#
	# "ø" :: Special value for empty/unset
	[ "${1:-}" != "ø" ]
}

dpv_string_lstrip() {
	#
	# Removes spaces from the left
	#
	remove_after_including="$(($1 + 1))"
	cut -c "$remove_after_including"-
}

dpv_string_uppercase() {
	#
	# String to uppercase
	#
	tr '[:lower:]' '[:upper:]' <<EOF
$1
EOF
}

dpv_string_lowercase() {
	#
	# String to lowercase
	#
	tr '[:upper:]' '[:lower:]' <<EOF
$1
EOF
}

dpv_string_regex_replace() {
	#
	# String replace with regex
	# Example: dpv_string_regex_replace "foo" "o" "x" -> "fxx"
	#
	string="${1:-}"
	from="${2:-}"
	to="${3:-}"

	sed "s/$from/$to/" <<EOF
$string
EOF
}

dpv_string_count_characters() {
	#
	# Count characters in string
	# Example: dpv_string_count_characters "foo" "o" -> 2
	#
	string="${1:-}"
	char="${2:-}"
	tr -cd "$char" <<EOF | wc -c | tr -d '[:space:]'
$string
EOF
}

dpv_internal_main "$@" # @main
