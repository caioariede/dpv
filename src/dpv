#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv internal-instrument)"
#
# Usage:
#   Go to the directory of the project and call "dpv"
#
# Code guidelines:
#
# 1. Internal commands should be prefixed with "internal-"
# 2. Commands are displayed in the usage by alphabetical order
# 3. There are four kinds of functions:
#    - command function
#    - command variant functions
#    - initialization functions
#    - short-hand functions
#    - utility functions
# 4. Command functions should be named "cmd_{command name}"
# 5. Command variants functions should be named "cmd_{command name}_{variant}"
# 6. Initialization functions should be named "init_{name}"
# 7. Short-hand functions differently than utilities are not pure
# 8. Utilities are "pure" functions and should be prefixed with "__"
# 9. Exit codes should be stored in constants prefixed with "ERR_"

set -e

ERR_CANNOT_DETERMINE_PYTHON_VERSION=2
ERR_CANNOT_ACTIVATE_VIRTUALENV=3
ERR_NO_INSTALL_METHOD=4
ERR_INVALID_ARGUMENT=5

#
# Command functions
#

cmd_help() {
	init_config_vars

	echo "dpv $CFG_VERSION"
	echo
	echo "usage: dpv [python version]"
	echo
	echo "commands:"
	echo "  dpv help             - display these instructions"
	echo "  dpv list             - list virtualenvs created with dpv"
	echo "  dpv run [command]    - run command inside virtualenv [default: \$SHELL]"
	echo "    --python [version] - specify python version"
	echo "    --temp             - use a temporary virtualenv"
	echo "  dpv versions         - display available python versions"
	echo "    --extended         - display extended list of available python versions"
	echo
	echo "global arguments:"
	echo "  --pyenv              - use pyenv"
	echo "  --homebrew           - use homebrew"
	echo
	echo "aliases:"
	echo "  dpv / dpv run"
	echo "  dpv [version] / dpv run --python [version]"
	echo "  dpv -h / dpv help"
	echo "  dpv -l / dpv ls / dpv list"
	echo "  dpv -v / dpv versions"
	echo "  dpv --homebrew / dpv --brew"
	echo
}

cmd_versions() {
	init_config_vars

	case "$1" in
	--installed)
		echo "installed python versions"
		echo
		if (_has_pyenv); then
			if result=$(_get_installed_versions_pyenv); then
				echo "pyenv: $(echo "$result" | __nl_to_space)"
			else
				echo "pyenv: failed, check logs"
			fi
		fi
		if (_has_homebrew); then
			if result=$(_get_installed_versions_homebrew); then
				echo "homebrew: $(echo "$result" | __nl_to_space)"
			else
				echo "homebrew: failed, check logs"
			fi
		fi
		;;
	--extended)
		echo "available python versions (extended list)"
		echo
		if (_has_pyenv); then
			local versions=""
			for version in $(_get_installed_versions_pyenv); do
				versions+=":$version*:"
			done
			for version in $(_get_available_versions_pyenv); do
				if [[ "$versions" != *":$version*:"* ]]; then
					versions+=":$version:"
				fi
			done
			if [[ "$versions" != "" ]]; then
				printf "pyenv: $(echo -e "$versions" | __delimited_to_nl | __sort_versions | _highlight_installed_pyenv | __nl_to_space)\n"
			else
				echo "pyenv: failed, check logs"
			fi
		fi
		if (_has_homebrew); then
			if result=$(_get_available_versions_homebrew); then
				printf "homebrew: $(echo "$result" | __sort_versions | _highlight_installed_homebrew | __nl_to_space)\n"
			else
				echo "homebrew: failed, check logs"
			fi
		fi
		;;
	"")
		echo "available python versions"
		echo
		if (_has_pyenv); then
			local installed_versions=""
			local major_versions=""
			local major_version
			for version in $(_get_installed_versions_pyenv); do
				installed_versions+=":$version:"
				major_versions+=":$(echo "$version" | __major_version):"
			done
			local versions="$installed_versions"
			for version in $(_get_available_versions_pyenv | grep "^[3-9.]\+$"); do
				major_version=$(echo "$version" | __major_version)
				if [[ "$major_versions" != *":$major_version:"* ]]; then
					versions+=":$version:"
				fi
				major_versions+=":$major_version:"
			done
			if [[ "$versions" != "" ]]; then
				printf "pyenv: $(echo -n "$versions" | __delimited_to_nl | __sort_versions | _highlight_installed_pyenv | __nl_to_space)\n"
			else
				echo "pyenv: failed, check logs"
			fi
		fi
		if (_has_homebrew); then
			if result=$(_get_available_versions_homebrew); then
				printf "homebrew: $(echo "$result" | __sort_versions | _highlight_installed_homebrew | __nl_to_space)\n"
			else
				echo "homebrew: failed, check logs"
			fi
		fi
		;;
	*)
		echo "unknown argument: $1"
		;;
	esac
}

cmd_internal_instrument() {
	trap - EXIT

	# https://stackoverflow.com/a/13864829
	if [ -n "${DPV_VENV_DIR+x}" ]; then
		init_config_vars

		echo "source $DPV_VENV_DIR/bin/activate || exit $ERR_CANNOT_ACTIVATE_VIRTUALENV"
	fi
}

cmd_list() {
	init_config_vars

	find "$CFG_VENVS_DIR" -maxdepth 2 -mindepth 2
}

cmd_run() {
	init_config_vars

	CMD=""

	while [[ "$#" -gt 0 ]]; do
		if [ "$CMD" == "" ]; then
			case "$1" in
			--python)
				shift
				ARG_PYTHON_VERSION="$1"
				shift
				;;
			--temp)
				ARG_TEMP=1
				shift
				;;
			-*)
				echo "invalid argument: $1"
				exit "$ERR_INVALID_ARGUMENT"
				;;
			*)
				CMD=" $1"
				shift
				;;
			esac
		else
			CMD+=" $1"
			shift
		fi
	done

	init_virtualenv_vars

	CMD=${CMD:1}

	if [ -f "$VENV_DIR/dpv.cfg" ]; then
		_log "- found existing virtualenv at $VENV_DIR"
	else
		init_python_vars

		"$PY_EXECUTABLE" -m venv "$VENV_DIR"
		echo -e "path = $PWD\nversion = $VENV_PYTHON_VERSION" >"$VENV_DIR/dpv.cfg"
		_log "- created virtualenv at $VENV_DIR"
	fi

	if [ -n "${DPV_VENV_DIR+x}" ]; then
		trap - EXIT
		exit 0
	fi

	if [ "$CMD" == "" ]; then
		echo "dpv - python $VENV_PYTHON_VERSION activated"
		_print_logs
		DPV_VENV_DIR=$VENV_DIR "$SHELL"
		trap - EXIT
	else
		PATH=$VENV_DIR/bin:$PATH $CMD
	fi
}

#
# Initialization functions
#

init_config_vars() {
	#
	# Initialize CFG_* variables
	#
	CFG_LOG_FILE=$(mktemp "${TMPDIR:-/tmp/}dpv_logs.XXXXX")
	CFG_AVAILABLE_INSTALL_METHODS=""
	CFG_PYENV_EXECUTABLE="${PYENV_EXECUTABLE:-pyenv}"
	CFG_HOMEBREW_EXECUTABLE="${HOMEBREW_EXECUTABLE:-brew}"
	CFG_USE_PYENV=${ARG_USE_PYENV:-0}
	CFG_USE_HOMEBREW=${ARG_USE_HOMEBREW:-0}

	if [ "$CFG_USE_PYENV $CFG_USE_HOMEBREW" == "1 1" ]; then
		echo "you should specify either --pyenv or --homebrew, not both"
		exit $ERR_INVALID_ARGUMENT
	elif [ "$CFG_USE_PYENV" == "1" ]; then
		CFG_INSTALL_METHOD="pyenv"
	elif [ "$CFG_USE_HOMEBREW" == "1" ]; then
		CFG_INSTALL_METHOD="homebrew"
	fi

	if hash "$CFG_PYENV_EXECUTABLE" 2>/dev/null; then
		# https://stackoverflow.com/a/677212
		CFG_AVAILABLE_INSTALL_METHODS+="pyenv;"
		if [ "$CFG_INSTALL_METHOD" == "" ] || [ "$CFG_INSTALL_METHOD" == "pyenv" ]; then
			_log "- pyenv is installed and is the preferred installation method"
			CFG_INSTALL_METHOD="pyenv"
		else
			_log "- pyenv is installed"
		fi
	else
		if [ "$CFG_USE_PYENV" == "1" ]; then
			echo "pyenv is not installed (executable: $CFG_PYENV_EXECUTABLE)"
			exit "$ERR_INVALID_ARGUMENT"
		fi

		_log "- pyenv is not installed (executable: $CFG_PYENV_EXECUTABLE)"
	fi

	if hash "$CFG_HOMEBREW_EXECUTABLE" 2>/dev/null; then
		CFG_AVAILABLE_INSTALL_METHODS+="homebrew;"
		if [ "$CFG_INSTALL_METHOD" == "" ] || [ "$CFG_INSTALL_METHOD" == "homebrew" ]; then
			_log "- homebrew is installed and is the preferred installation method"
			CFG_INSTALL_METHOD="homebrew"
		else
			_log "- homebrew is installed"
		fi
	else
		if [ "$CFG_USE_HOMEBREW" == "1" ]; then
			echo "homebrew is not installed (executable: $CFG_HOMEBREW_EXECUTABLE)"
			exit "$ERR_INVALID_ARGUMENT"
		fi

		_log "- homebrew is not installed (executable: $CFG_HOMEBREW_EXECUTABLE)"
	fi

	if [ "$CFG_INSTALL_METHOD" == "" ]; then
		exit "$ERR_NO_INSTALL_METHOD"
	fi

	CFG_VERSION="1.0.0"
	CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
	CFG_VENVS_DIR="$CFG_DIR/virtualenvs"

	mkdir -p "$CFG_VENVS_DIR"
}

init_virtualenv_vars() {
	#
	# Initialize VENV_ variables
	#
	# Depends on init_config_vars
	#
	VENV_PYTHON_VERSION="$ARG_PYTHON_VERSION"

	# try to locate existing virtualenv
	while IFS= read -r file; do
		local path
		local version
		while IFS= read -r line; do
			if [[ "$line" =~ ^path\ *=\ *(.*) ]]; then
				path="${BASH_REMATCH[1]}"
			elif [[ "$line" =~ ^version\ *=\ *(.*) ]]; then
				version="${BASH_REMATCH[1]}"
			fi
		done <"$file"
		if [[ "$path" == "$PWD" ]]; then
			if [[ "$ARG_PYTHON_VERSION" == "" ]] || [[ "$version" == "$ARG_PYTHON_VERSION"* ]]; then
				newer_version="$(printf "%s\n%s" "$VENV_PYTHON_VERSION" "$version" | __sort_versions | head -n 1)"
				if [[ "$version" == "$newer_version" ]]; then
					VENV_PYTHON_VERSION=$version
					if [ "$ARG_TEMP" == "1" ]; then
						VENV_DIR=$(_mktemp_venv_dir)
					else
						VENV_DIR=$(dirname "$file")
					fi
				fi
			fi
		fi
	done < <(find "$CFG_VENVS_DIR" -name dpv.cfg -type f -mindepth 3 -maxdepth 3)

	# try to detect python version from runtime.txt file
	if [ "$VENV_PYTHON_VERSION" == "" ]; then
		_log "- no existing virtualenvs found for $PWD"

		if [ -f "runtime.txt" ]; then
			VENV_PYTHON_VERSION=$(sed 's/^python\-//' <runtime.txt)
			_log "- parsed python version $VENV_PYTHON_VERSION from runtime.txt file"
		else
			_log "- no $PWD/runtime.txt file found"
		fi
	fi

	# otherwise, prompt user about the python version
	if [ "$VENV_PYTHON_VERSION" == "" ]; then
		local default_version=""
		if (_has_pyenv); then
			default_version=$(cut -d: -f2 <(_get_installed_versions_pyenv) <(_get_available_versions_pyenv))
		elif (_has_homebrew); then
			default_version=$(cut -d: -f2 <(_get_installed_versions_homebrew) <(_get_available_versions_homebrew))
		fi
		read -rp "python version [$default_version]: " VENV_PYTHON_VERSION
		VENV_PYTHON_VERSION=${VENV_PYTHON_VERSION:-$default_version}
		_log "- using python version from input: $VENV_PYTHON_VERSION"
	fi

	if [ "$VENV_PYTHON_VERSION" == "" ]; then
		exit "$ERR_CANNOT_DETERMINE_PYTHON_VERSION"
	fi

	# normalize python version according to install method
	local version
	case "$CFG_INSTALL_METHOD" in
	pyenv)
		version=$(_resolve_version_pyenv "$VENV_PYTHON_VERSION")
		;;
	homebrew)
		version=$(_resolve_version_homebrew "$(echo "$VENV_PYTHON_VERSION" | __normalize_version_homebrew)")
		;;
	esac

	if [ "$VENV_PYTHON_VERSION" != "$version" ]; then
		_log "- python version $VENV_PYTHON_VERSION resolved to $version"
		VENV_PYTHON_VERSION=$version
	fi

	if [ "$ARG_TEMP" == "1" ]; then
		VENV_DIR=$(_mktemp_venv_dir)
	else
		VENV_DIR=${VENV_DIR:-$CFG_VENVS_DIR/$VENV_PYTHON_VERSION/$(basename "$PWD")-$VENV_PYTHON_VERSION}
	fi
}

init_python_vars() {
	#
	# Initialize PY_ variables
	#
	# Depends on init_config_vars, init_virtualenv_vars
	#
	local python_version="$VENV_PYTHON_VERSION"

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		if [[ "$(_get_installed_versions_pyenv | __nl_to_delimited)" != *":$python_version:"* ]]; then
			echo "installing python $python_version using pyenv"
			_exec_pyenv install "$python_version" 2>&1 | sed 's/^/  > /'
			echo "ok"
		else
			_log "- python $python_version is currently installed by pyenv"
		fi

		PY_PREFIX=$(_exec_pyenv prefix "$python_version")
		PY_EXECUTABLE="$PY_PREFIX/bin/python"
		;;
	homebrew)
		python_version=$(echo "$python_version" | __normalize_version_homebrew)
		if [ "$python_version" != "$VENV_PYTHON_VERSION" ]; then
			_log "- homebrew only supports 3.y python versions, using $python_version"
		fi

		if [[ "$(_get_installed_versions_homebrew)" != *":$python_version:"* ]]; then
			echo "installing python $python_version using homebrew"
			HOMEBREW_NO_AUTO_UPDATE=1 brew install "python@$python_version" 2>&1 | sed 's/^/  > /'
			echo "ok"
		fi

		PY_PREFIX=$(_exec_homebrew --prefix "python@$python_version")
		PY_EXECUTABLE="$PY_PREFIX/bin/python3"
		;;
	esac
}

#
# Main function
#

main() {
	trap 'error_handling $?' EXIT

	CMD=""
	CMD_ARGS=""

	# parse global arguments
	for i in "$@"; do
		case $i in
		--pyenv)
			ARG_USE_PYENV=1
			;;
		--homebrew | --brew)
			ARG_USE_HOMEBREW=1
			;;
		--*)
			CMD_ARGS+=" $i"
			;;
		*)
			case "$i" in
			internal-instrument | list | ls | -l | 2* | 3* | 4* | run | versions | -v | help | -h)
				if [ "$CMD" == "" ]; then
					CMD="$i"
				else
					CMD_ARGS+=" $i"
				fi
				;;
			*)
				CMD_ARGS+=" $i"
				;;
			esac
			;;
		esac
	done

	CMD_ARGS=${CMD_ARGS:1} # drop leading space

	case "$CMD" in
	internal-instrument)
		cmd_internal_instrument
		;;

	list | ls | -l)
		cmd_list
		;;

	2* | 3* | 4*)
		if [[ "$CMD_ARGS" == *"--python"* ]]; then
			trap - EXIT
			echo "dpv cannot run \"dpv [version]\" with \"--python\" - use one or the other"
			exit "$ERR_INVALID_ARGUMENT"
		fi

		# shellcheck disable=2086
		cmd_run --python "$1" $CMD_ARGS
		;;

	run | "")
		# shellcheck disable=2086
		cmd_run $CMD_ARGS
		;;

	versions | -v)
		# shellcheck disable=2086
		cmd_versions $CMD_ARGS
		;;

	help | -h)
		cmd_help
		;;

	*)
		trap - EXIT
		echo "dpv invalid subcommand: $CMD"
		exit "$ERR_INVALID_ARGUMENT"
		;;

	esac
}

#
# Error-handling
#

error_handling() {
	case "$1" in

	"$ERR_CANNOT_DETERMINE_PYTHON_VERSION")
		echo "failed to determine python version for $PWD"
		;;

	"$ERR_CANNOT_ACTIVATE_VIRTUALENV")
		echo "failed to activate virtualenv $VENV_DIR"
		;;

	"$ERR_NO_INSTALL_METHOD")
		echo "no installation method to pick"
		;;

	"$ERR_INVALID_ARGUMENT")
		exit
		;;

	esac

	if [ -z "${DPV_INSTRUMENT+x}" ]; then
		_print_logs
	else
		if [ -n "${DPV_VENV_DIR+x}" ]; then
			echo "unset DPV_VENV_DIR"
			echo "exit 1"
		fi
	fi
}

#
# Short-hand functions
#

_exec_pyenv() {
	"$CFG_PYENV_EXECUTABLE" "$@"
}

_exec_homebrew() {
	"$CFG_HOMEBREW_EXECUTABLE" "$@"
}

_log() {
	echo -e "$@" >>"$CFG_LOG_FILE"
}

_print_logs() {
	echo
	echo "logs:"
	sed 's/^/  /' <"$CFG_LOG_FILE"
	echo
}

_run_command_log_failure() {
	tmpfile=$(mktemp)

	# shellcheck disable=SC2068
	if $@ &>"$tmpfile"; then
		cat "$tmpfile"
		exit 0
	else
		_log "- failed to run command: $*"
		_log "$(sed 's/^/  > /' <"$tmpfile")"
		exit 1
	fi
}

_has_pyenv() {
	[[ "$CFG_AVAILABLE_INSTALL_METHODS" =~ "pyenv;" ]] || exit 1
}

_has_homebrew() {
	[[ "$CFG_AVAILABLE_INSTALL_METHODS" =~ "homebrew;" ]] || exit 1
}

_get_installed_versions_pyenv() {
	if [ -n "${_CACHED_INSTALLED_VERSIONS_PYENV-x}" ]; then
		if result=$(_run_command_log_failure "$CFG_PYENV_EXECUTABLE versions --bare --skip-aliases"); then
			result=$(echo "$result" | cut -d/ -f1 | uniq | __sort_versions)
			_CACHED_INSTALLED_VERSIONS_PYENV=$result
		else
			exit 1
		fi
	fi
	echo -n "$_CACHED_INSTALLED_VERSIONS_PYENV"
}

_get_available_versions_pyenv() {
	if [ -n "${_CACHED_AVAILABLE_VERSIONS_PYENV-x}" ]; then
		if result=$(_run_command_log_failure "$CFG_PYENV_EXECUTABLE install --list"); then
			result=$(echo "$result" | sed 's/ //g' | __sort_versions)
			_CACHED_AVAILABLE_VERSIONS_PYENV=$result
		else
			exit 1
		fi
	fi
	echo -n "$_CACHED_AVAILABLE_VERSIONS_PYENV"
}

_get_available_versions_homebrew() {
	if [ -n "${_CACHED_AVAILABLE_VERSIONS_HOMEBREW-x}" ]; then
		if result=$(_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE search python"); then
			result=$(echo "$result" | grep -o 'python@[^ ]\+' | cut -d@ -f2 | __sort_versions)
			_CACHED_AVAILABLE_VERSIONS_HOMEBREW=$result
		else
			exit 1
		fi
	fi
	echo -n "$_CACHED_AVAILABLE_VERSIONS_HOMEBREW"
}

_get_installed_versions_homebrew() {
	if [ -n "${_CACHED_INSTALLED_VERSIONS_HOMEBREW-x}" ]; then
		if result=$(_run_command_log_failure "$CFG_HOMEBREW_EXECUTABLE list"); then
			result=$(echo "$result" | grep 'python@' | cut -d@ -f2 | __sort_versions)
			_CACHED_INSTALLED_VERSIONS_HOMEBREW=$result
		else
			exit 1
		fi
	fi

	echo -n "$_CACHED_INSTALLED_VERSIONS_HOMEBREW"
}

_get_all_versions_homebrew() {
	printf "%s\n%s" "$(_get_installed_versions_homebrew)" "$(_get_available_versions_homebrew)" | sed 's/\n\n*/\n/g'
}

_mktemp_venv_dir() {
	mktemp -d "${TMPDIR:-/tmp/}$(basename "$PWD")-$VENV_PYTHON_VERSION.tmpXXXXX"
}

_resolve_version_pyenv() {
	local versions
	versions="$(_get_installed_versions_pyenv)$(_get_available_versions_pyenv)"

	for line in $(echo "$versions" | sed -E 's/:/\n/g'); do
		if [[ "$line" == "$1."* ]] || [[ "$line" == "$1" ]]; then
			echo "$line"
			exit
		fi
	done

	_log "- cannot resolve version $1 (available versions are: $(echo "$versions" | __sort_versions | __nl_to_space))"
	exit 1
}

_resolve_version_homebrew() {
	if [[ "$1" =~ ^[0-9]*\.[0-9]*$ ]]; then
		"$(_exec_homebrew --prefix "python@$1")"/bin/python3 --version | cut -d\  -f2
	else
		for line in $(_get_installed_versions_homebrew); do
			if [[ "$line" == "$1."* ]]; then
				"$(_exec_homebrew --prefix "python@$line")"/bin/python3 --version | cut -d\  -f2
				break
			fi
		done
	fi
}

_highlight_installed_pyenv() {
	local regex
	regex=$(_get_installed_versions_pyenv | sed -E 's/(\.)/\\\1/g' | tr '\n' '|')
	sed -E "s/($regex)/\\\e[38;5;81m\\1*\\\e[0m/g"
}

_highlight_installed_homebrew() {
	local regex
	regex=$(_get_installed_versions_homebrew | sed -E 's/(\.)/\\\1/g' | tr '\n' '|')
	sed -E "s/($regex)/\\\e[38;5;81m\\1*\\\e[0m/g"
}

#
# Utilities that work over stdin
#

__nl_to_delimited() {
	# a\nb\n\nc\n\n => :a:b:c:
	tr '\n' ':' | sed -E 's/^|$|:+/:/g'
}

__nl_to_space() {
	tr '\n' ' '
}

__delimited_to_nl() {
	sed -E 's/^:*|:*$//g' | sed -E 's/::*/\n/g'
}

__normalize_version_homebrew() {
	# 3.7.12 => 3.7
	sed 's/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)$/\1.\2/'
}

__sort_versions() {
	sort --version-sort --reverse
}

__major_version() {
	cut -d. -f1,2
}

main "$@"
