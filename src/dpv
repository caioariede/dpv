#!/usr/bin/env bash
#
# Dead-simple Python Virtualenvs
#
# Installation:
#   1. Copy this file to /usr/local/bin/dpv
#   2. Give execution permission: "chmod +x /usr/local/bin/dpv"
#   3. Add this line to your ~/.zshrc (or whatever):
#
#       eval "$(dpv instrument)"
#
#   4. Make sure pyenv is installed: brew install pyenv
#
# Usage:
#   Go to the directory of the project and call "dpv"
#   If it complains that the Python version is not installed, use: pyenv install <version>
#
set -e

function cmd_usage() {
	_load_config_vars

	echo "dpv $CFG_VERSION [installation methods: $CFG_ALL_INSTALL_METHODS]"
	echo
	echo "usage:"
	echo "  dpv             - installs virtualenv for the current directory"
	echo "  dpv usage       - display these instructions"
	echo "  dpv list        - lists virtualenvs managed by dpv"
	echo "  dpv where       - display the virtualenv directory"
	echo "  dpv version     - display version"
	echo "  dpv instrument  - instruments dpv"
	echo "  dpv run [cmd]   - runs command inside virtualenv [default: \$SHELL]"
	echo
	echo "  CTRL-D          - exits virtualenv"
	echo

}

function cmd_version() {
	_load_config_vars
	echo "$CFG_VERSION"
}

function cmd_where() {
	_load_config_vars
	_load_python_vars
	_where
}

function cmd_instrument() {
	# https://stackoverflow.com/a/13864829
	if [ -n "${DPV_SHELL+x}" ]; then
		_load_config_vars
		_load_python_vars
		_print_venv_activate
	fi
}

function cmd_list() {
	case "$1" in
	--plain | *)
		_load_config_vars
		_plain_list
		;;
	esac
}

function cmd_run() {
	_load_config_vars
	_load_python_vars

	if [ ! -d "$VENV_DIR" ]; then
		_create_venv_if_not_exists
		_persist
	fi

	_run_command "$@"
}

function cmd_persist() {
	_load_config_vars
	_persist
}

function cmd_install() {
	_load_config_vars
	_install
}

function err_detecting_python_version() {
	echo "cannot determine python version for $PWD" >/dev/stderr

	_print_exit_shell
}

function err_activate_virtualenv() {
	echo "cannot activate the virtualenv" >/dev/stderr

	_print_exit_shell
}

function __main() {
	trap '_error_handling $?' EXIT

	case "$1" in
	where)
		cmd_where
		;;

	instrument)
		cmd_instrument
		;;

	list | ls)
		cmd_list "${2:--plain}"
		;;

	run | "")
		if [ "$#" -lt 2 ]; then
			cmd_run "$SHELL"
		else
			cmd_run "${@:2}"
		fi
		;;

	version | -v | --version)
		cmd_version
		;;

	persist)
		cmd_persist
		;;

	install)
		cmd_install
		;;

	usage)
		cmd_usage
		;;

	*)
		trap - EXIT
		echo "?"
		exit 1
		;;

	esac
}

function _error_handling() {
	case "$1" in

	2)
		err_detecting_python_version
		;;

	3)
		err_activate_virtualenv
		;;

	esac
}

function _run_command() {
	if [ -n "${DPV_SHELL+x}" ]; then
		exit 0
	fi

	DPV_SHELL=1 "$@"
}

function _load_config_vars() {
	CFG_INSTALL_METHOD="${DPV_INSTALL_METHOD}"
	CFG_ALL_INSTALL_METHODS=""

	# https://stackoverflow.com/a/677212
	if hash pyenv 2>/dev/null; then
		CFG_ALL_INSTALL_METHODS+=" pyenv"
		if [ "$CFG_INSTALL_METHOD" == "pyenv" ] || [ "$CFG_INSTALL_METHOD" == "" ]; then
            CFG_INSTALL_METHOD="pyenv"
			CFG_ALL_INSTALL_METHODS+="*"
		fi
	fi
	if hash brew 2>/dev/null; then
		CFG_ALL_INSTALL_METHODS+=" homebrew"
		if [ "$CFG_INSTALL_METHOD" == "homebrew" ] || [ "$CFG_INSTALL_METHOD" == "" ]; then
            CFG_INSTALL_METHOD="homebrew"
			CFG_ALL_INSTALL_METHODS+="*"
		fi
	fi

	# remove blank space from start
	CFG_ALL_INSTALL_METHODS="${CFG_ALL_INSTALL_METHODS:1}"

	CFG_VERSION="1.0.0"
	CFG_DIR="${DPV_DIR:-$HOME/.dpv}"
	CFG_VENVS_DIR="$CFG_DIR/virtualenvs"
	CFG_VENVS_PERSIST_FILE="$CFG_DIR/virtualenvs.txt"

	mkdir -p "$CFG_VENVS_DIR"
}

function _load_python_vars() {
	PY_VERSION=$(_get_python_version)
	PY_PREFIX=$(_get_python_prefix)

	case "$CFG_INSTALL_METHOD" in
	pyenv)
		PY_EXECUTABLE="$PY_PREFIX/bin/python"
		;;
	homebrew)
		PY_EXECUTABLE="$PY_PREFIX/bin/python3"
		;;
	esac

	VENV_DIR=$CFG_VENVS_DIR/$PY_VERSION/$(basename "$PWD")-$PY_VERSION
}

function _get_python_version() {
	if [ -f "runtime.txt" ]; then
		sed 's/^python\-//' <runtime.txt
	else
		exit 2
	fi
}

function _get_python_prefix() {
	case "$CFG_INSTALL_METHOD" in
	pyenv)
		pyenv prefix "$PY_VERSION"
		;;
	homebrew)
		brew --prefix "python@$PY_VERSION"
		;;
	esac
}

function _create_venv_if_not_exists() {
	if [ ! -d "$VENV_DIR" ]; then
		"$PY_EXECUTABLE" -m venv "$VENV_DIR"
	fi
}

function _print_venv_activate() {
	echo "source $VENV_DIR/bin/activate || exit 2"
}

function _where() {
	PY_VERSION=$(_get_python_version)
	PY_PREFIX=$(_get_python_prefix)
	VENV_DIR=$CFG_VENVS_DIR/$PY_VERSION/$(basename "$PWD")-$PY_VERSION

	echo "$VENV_DIR"
}

function _plain_list() {
	if [ ! -f "$CFG_VENVS_PERSIST_FILE" ]; then
		_persist
	fi

	while IFS= read -r line; do
		IFS=$'\t' read -r -a lst <<<"$line"
		PY_VERSION=${lst[0]}
		PY_PREFIX=${lst[1]}
		if [ -d "$PY_PREFIX" ]; then
			echo -e "${lst[0]}\t${lst[1]}\tINSTALLED"
		else
			echo -e "${lst[0]}\t${lst[1]}\tNOT INSTALLED"
		fi
	done < <(cat "$CFG_VENVS_PERSIST_FILE")
}

function _persist() {
	true >"$CFG_VENVS_PERSIST_FILE"

	while read -r path; do
		printf "%s\t%s\n" "$(basename "$path")" "$path" >>"$CFG_VENVS_PERSIST_FILE"
	done < <(compgen -G "$CFG_VENVS_DIR/*/*" || true)
}

function _install() {
	while IFS= read -r line; do
		IFS=$'\t' read -r -a lst <<<"$line"
		PY_VERSION=${lst[0]}
		PY_PREFIX=$(_get_python_prefix)
		VENV_DIR="${lst[1]}"
		if [ ! -f "$PY_PREFIX" ]; then
			echo "Installing $VENV_DIR"
			_create_venv_if_not_exists
		fi
	done < <(_plain_list)
}

function _print_exit_shell() {
	if [ -n "${DPV_SHELL+x}" ]; then
		echo "unset DPV_SHELL"
		echo "exit 1"
	fi
}

function _get_installation_method() {
	if [ -n "${CFG_INSTALL_METHOD+x}" ]; then
		echo "$CFG_INSTALL_METHOD"
	else
		IFS=" " read -r -a installation_methods <<<"$CFG_ALL_INSTALL_METHODS"
		echo "${installation_methods[0]}"
	fi
}

__main "$@"
